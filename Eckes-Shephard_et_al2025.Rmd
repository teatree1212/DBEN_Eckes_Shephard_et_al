---
title: "Paper0_analysis_code"
author: "Annemarie Eckes-Shephard"
date: "2024-09-24"
output:
  html_document:
    df_print: paged
---

#THIS ONE

### Setup instructions

1) download the model outputs and benchmarking data from:

e.g. zenodo?

2) install DGVMTools from:
https://github.com/MagicForrest/DGVMTools

```{r installDGVMTOOLS, eval=TRUE}
library(devtools)
#install_github("MagicForrest/DGVMTools")
library("DGVMTools")
library(ggpubr)
```

```{r source_DBEN_helper_functions_other_setup}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)

base.path <- "./"

Figs_dir <- paste0("../Figs/")

#create new Figures directory, if it does not yet exist:
ifelse(!dir.exists(file.path("../Figs")), dir.create(file.path("../Figs")), FALSE)

source(paste0("Format-DBEN_Eckes-Shephard_et_al2025.R"))
source(paste0("DBEN_helper_functions.R"))

obs.path <-paste0("../observations/2_processed/")

simdate = "20250107"#

#create new date-output directory, if it does not yet exist:
ifelse(!dir.exists(file.path("../Figs/", simdate)), dir.create(file.path("../Figs/", simdate)), FALSE)


# sampling of random numbers for forcing data before running the models (see Notes S1 - simulation protocol):
set.seed(143)
1990+sample.int(30, 30)


# related to plotting aesthetics
library(plotrix)

#note: always pass alpha on the 0-255 scale
makeTransparent<-function(someColor, alpha=100){
  newColor<-col2rgb(someColor)
  apply(newColor, 2, function(curcoldata){rgb(red=curcoldata[1], green=curcoldata[2],
                                              blue=curcoldata[3],alpha=alpha, maxColorValue=255)})
}

abc <- function(site){
  idx <- which(sites==site)
  abc <- c("a)", "b)" ,"c)")

  return(abc[idx])
}

def <- function(site){
  idx <- which(sites==site)
  abc <- c("d)", "e)" ,"f)")

  return(abc[idx])
}


ghi <- function(site){
  idx <- which(sites==site)
  abc <- c("g)", "h)" ,"i)")

  return(abc[idx])
}

```

```{r select_equilibrium_period}
# reported in Table S1.5
# for some calculations, the model-specific dynamic equilibrium period after regrowth has finished is required
# the values are derived by eyeballing the timeseries of cwood variable for each model, and
# visually determining when an equilibrium has emerged.
# (i.e.changes in cwood are marginal or the amplitude size repeats itself.)

eq_values_FIN <- data.frame(lower=rep(NA,9))
eq_values_FIN$lower  <- c(200, 300,   150 ,320,   320 ,  600, 715, 300  , 500)
eq_values_FIN$upper  <- c(420,  450,   320, 450,   450,   900,  810,  420,   530)
eq_values_FIN$model  <- models_avail

eq_values_BIA        <- data.frame(lower=rep(NA,9))
eq_values_BIA$lower  <- c(200, 300 ,  150, 320 ,  320  , 600 ,700 ,240 ,  500)
eq_values_BIA$upper  <- c(420, 450 , 320, 450,  450,  900, 810, 450 , 530)
eq_values_BIA$model  <- models_avail


eq_values_BCI        <- data.frame(lower=rep(NA,9))
eq_values_BCI$lower  <- c(150, 250,  150, 320 ,  320  , 600, 500 ,  100  , 500) #LSM_DVM_comp$BCI$lower[1:lgth] # LPJG: 420 CABLE-POP: 1
eq_values_BCI$upper  <- c(420 ,450 , 320 ,450 , 450 , 900 ,810 , 450,  530) #LSM_DVM_comp$BCI$upper[1:lgth]# LPJG: 864 CABLE-POP: 30
eq_values_BCI$model  <- models_avail

eq_values <- list(eq_values_FIN,eq_values_BIA,eq_values_BCI)
names(eq_values) <- sites

#####################
#for manuscript:
eq_values_FIN$site <- "FIN"
eq_values_BIA$site <- "BIA"
eq_values_BCI$site <- "BCI"
eq_values_table <- rbind(eq_values_FIN,eq_values_BIA,eq_values_BCI)

knitr::kable(eq_values_table[order(eq_values_table$model),], caption="Upper and lower simulation year that make up the period from which each model is considered in equilibrium. Some models were run for a longer timeperiod than the prescribed 450 years in order to achieve a mature forest in equilibrium state.")
```


# Cbudget closure checks

```{r budget_closed_used_in_cbudget_instructions}
#STABLE -NOT CLEANED

png(file=paste0(Figs_dir,simdate,"/S1_woody_carbon_budget.png"),width=215,height=340,units="mm",res =300)

par(mfrow=c(9,3),mar=c(1.5,0,2.2,0),oma=c(2.3,3.3,0.7,0.2))
#par(mfrow=c(1,3),mar=c(1.5,0,2.2,0),oma=c(2.3,3.3,0.7,0.2))

for(model_name in models_avail){

  run  = "P0"
  for(site in c("FIN","BIA","BCI")){


    #some mode-specific use of variables necessary (see table S)
    if(model_name == "ORCHIDEE"){

      WBgrowth <- get_model_output(var="WBgrowth",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
      cmort    <- get_model_output(var="cmort",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
      cwood    <- get_model_output(var="cwood",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")

      test_Wbudget_tolerance_threshold(WBgrowth_in= WBgrowth@data$Total, cmort_in= cmort@data$Total, site=site,model_name=model_name, cwood_in= cwood@data$Total,time_range = 32:410)
    }else{
    if(model_name == "FATES"){
      #To compare growth v mortality +  turnover you need  to
      #compare  Bgrowth and cmort - these are all tissues and not by pft."
      DVM_cwood   <- get_output_FATES(site=site,run="P0", var="cveg",
                                    model_name=model_name, file.dir=file.dir.fates,
                                    co2_levels = "412ppm")
      DVM_cmort   <- get_output_FATES(site=site, run="P0", var="cmort",
                                     model_name=model_name, file.dir=file.dir.fates,
                                     co2_levels = "412ppm")

      DVM_WBgrowth <- get_output_FATES(site=site, run="P0", var="Bgrowth",
                                       model_name=model_name, file.dir=file.dir.fates,
                                       co2_levels = "412ppm")
      }else if(model_name=="BiomeE-Standalone"){
        #WDgrow+ WDrepr  (new seedlings from reproduction)+ WDmgrt (migrated plants, once in year 31) = WDgrowTot
        #WDkill + WDmgrt + WDmgrt + WDmort
        # note that when retrieving var = WDgrowthTot, this variable is automatically updated as "WBgrowth":
        DVM_WBgrowth <- get_model_output(site=site, run="P0", var="WDgrowTot",
                                       model_name=model_name,
                                       co2_levels = "412ppm")
        # note that when calling WDmorthTot, this variable is automatically updated as "cmort":
        DVM_cmort <- get_model_output(site=site, run="P0", var="WDmortTot",
                                       model_name=model_name,
                                       co2_levels = "412ppm")

        DVM_cwood    <- get_model_output(var="cwood_size",site=site,run="P0",
                                         model_name=model_name,
                                         co2_levels = "412ppm")
      }else{
        DVM_WBgrowth <- get_model_output(var="WBgrowth",site=site,run="P0",
                                         model_name=model_name,
                                         co2_levels = "412ppm")
        DVM_cmort    <- get_model_output(var="cmort",site=site,run="P0",
                                         model_name=model_name,
                                         co2_levels = "412ppm")
        DVM_cwood    <- get_model_output(var="cwood_size",site=site,
                                         run="P0",model_name=model_name,
                                         co2_levels = "412ppm")


      }
      #remove the first 30 years of equilibrium. here we focus on the regrowth phase:
      cwood <- omit_equilibrium_phase(DVM_cwood,model_name=model_name,site=site,selection_by_year=TRUE)
      cmort <- omit_equilibrium_phase(DVM_cmort,model_name=model_name,site=site,selection_by_year=TRUE)
      WBgrowth <- omit_equilibrium_phase(DVM_WBgrowth,model_name=model_name,site=site,selection_by_year=TRUE)

      lgth <- length(cwood@data$Total)
      # start from 2 to remove output writeout-timing problems with SEIB. This does not impact the validity of this test.
      test_Wbudget_tolerance_threshold(WBgrowth_in = WBgrowth@data$Total, cmort_in = cmort@data$Total,
                                       site = site,model_name = model_name, cwood_in = cwood@data$Total,
                                       time_range = 2:410)##post_dist_year[3]:410)
    }
    }
}
mtext(outer=TRUE,line=1,side=1,"Years since disturbance")
mtext(outer=TRUE,line=2,side=2,"cwood, KgC m-2")

dev.off()

```


> **Note:** This is a highlighted text box created using block quotes.
> You can add as many lines as you want here.

> explanations about variables used for carbon closure:
>
>From: Ensheng Weng <ew2560@columbia.edu>
>Sent: Tuesday, October 8, 2024 5:18 AM
>To: Annemarie Eckes-Shephard <annemarie.eckes-shephard@nateko.lu.se>
>Subject: Re: Fw: BiomeE rerun for total WDgrowth and WDmort fluxes
>
>Hi, Annemarie,
>Just a quick follow up about the reruns with woody carbon closure.
>I attached a sample file (BCI, aCO2. no disturbance) in this email. You can see the calculated wood carbon fits the simulated well.
>In the output files, the fluxes of WDgrow, WDmort, WDrepr  (new seedlings from reproduction), WDkill (killed trees because of low density), WDmgrt >(migrated plants, once in year 31) and WDdstb (removed by disturbance, year 31).
>The netCDF files with individual variables are in the shared google folder (link is in the last email of this thread).
>Let me know please if there are any problems.
>
>Best,
>Ensheng
>
>
>
>From: Jessica Needham <jfneedham@lbl.gov>Sent: Thursday, September 19, 2024 11:02 PMTo: Annemarie Eckes-Shephard ><annemarie.eckes-shephard@nateko.lu.se>Cc: Thomas Pugh <thomas.pugh@nateko.lu.se>; Charles Koven <cdkoven@lbl.gov>; Rosie Fisher ><rosie.fisher@cicero.oslo.no>Subject: Re: Updated FATES simulations
>
>(...)
>#FATES: cveg_total with Bgrowth and cmort.
>
>In my figure to check this (attached) I have input = npp (FATES_Bgrowth) and output = litter + seed decay (FATES_cmort). The Cumulative sum of npp - >(litter + seed decay) matches vegetation carbon + seed bank through time. Litter is all mortality plus any turnover of other tissues. NPP is >growth of woody + non woody tissues. I did this because vegetation carbon and mortality fluxes  in FATES also include non woody tissues, i.e we >don’t track loss of just woody carbon from mortality. I’d have to add new history variables if we wanted to do this.
>
>I just realized the reason it isn’t working in your files is because I didn’t include the seed bank in the cveg files I sent. I can remake those >and upload them to box. I guess this isn’t really a test of the woody carbon budget anymore but it gets really complicated with recruits anytime I >try to ignore seeds.
>(...)
>

# Benchmarks - all models

## regrowth and equilibrium dynamics

```{r Figure_1_regrowth_all_models_manuscript, eval=TRUE}

png(filename = paste0(Figs_dir,simdate,"/Figure1_Benchmark_regrowth_allmodels.png"),width=180,height=240,units = "mm",res=360)
#### regrowth curve + equilibrium biomass dynamics


par(mfcol=c(3,1),mar=c(0,3,0,0),oma=c(0,0,0.1,0.15),cex=0.8)
xlim = 300

var="AGcwood"
run  = "P0"
last_sim_year = 450

#load benchmark obs:
regrowth_obs <- read.csv(paste0(obs.path,"benchmark_regrowth_curves.csv"),head =TRUE)
eq_dyn_obs   <- read.csv(paste0(obs.path,"benchmark_eq_dynamics.csv"),head =TRUE)


###############################################################
# A timeseries plot on regrowing forest model output with chronosequence data.

for(site in sites){


  if(site=="FIN"){
    par(fig=c(0,0.75,0.70,1), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0))
    ylim=20
  }
  if(site =="BIA"){
    par(fig=c(0,0.75,0.40,0.70), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    ylim=20
  }
  if(site=="BCI"){
    par(fig=c(0,0.75,0.1,0.40), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    ylim=30
  }



  #load and plot models:
 for(model_name in models_avail){


  #get model_output
  model_out <-  get_model_output(site=site, run= run,
                                 var = var, model_name=model_name,
                                 co2_levels = "412ppm")

  if(model_name == models_avail[1]){
    plot(1:dim(model_out@data)[1], model_out@data$Total, type = "l",
         ylim = c(0,ylim),col = get_model_colour(model_name),lwd=1.5,
         xaxt = "n", yaxt = "n",xlab="",ylab="",xlim=c(0,xlim))
  }else{

     lines(1:dim(model_out@data)[1], model_out@data$Total,
           col = get_model_colour(model_name),lwd=1.5, xaxt = "n",
           yaxt = "n",xlab="",ylab="")
  }

 }
    #load and plot obs:
    biome <- biomes[which(sites==site)]
    # +30 to account for the 30 years equilibrium
    points(regrowth_obs[which(regrowth_obs$Biome == biome),]$bin_num+30,
           regrowth_obs[which(regrowth_obs$Biome == biome),]$AGcwood_kgCm2_med)
    # the same methods were applied to derive the ranges, and median,
    # 10th and 90th percentile are reported here:
    arrows(regrowth_obs[which(regrowth_obs$Biome == biome),]$bin_num+30,
           regrowth_obs[which(regrowth_obs$Biome == biome),]$AGcwood_kgCm2_10,
           regrowth_obs[which(regrowth_obs$Biome == biome),]$bin_num+30 ,
           regrowth_obs[which(regrowth_obs$Biome == biome),]$AGcwood_kgCm2_90,
           length = 0.01, angle = 90, code = 3,col = get_biome_colour(biome,black_only = TRUE),
           lwd = 1, lty=2 )


    #aesthetics:
    if(site == "BCI"){
     axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(1, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
     mtext("simulation year",side =1, line =1.5, outer=FALSE)
  }else{
     axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }


  mtext(paste0(abc(site)),adj=0.99,side=3,line=-1.1,cex = 0.8)
  mtext(paste(site),side=3,adj=-0.1,line=-2.2)

  if(site=="BIA"){
    mtext(side=2,expression(AGcwood~(kgC~m^-2)), line =1, cex=1)
  }

}


####################################################################################
# Add a separate mature forest AGcwood boxplot:

for(site in sites){

   if(site=="FIN"){
    par(fig=c(0.75,1,0.7,1), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
     ylim=20
  }
  if(site =="BIA"){
    par(fig=c(0.75,1,0.40,0.70), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    ylim=20
  }
  if(site=="BCI"){
    par(fig=c(0.75,1,0.1,0.40), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    ylim=30
  }


  #prepare eq_dyn_obs for plotting on the same graph as regrowth:
  eq_dyn_obs <- eq_dyn_obs %>% group_by(site) %>% mutate(new_plot_loc = last_sim_year + (Year - max(Year)))


  #load and plot models, as boxplots:
    lgth <- length(models_avail)
   for(i in 1:lgth){
    model_name <- models_avail[i] # calling models this like this, because I need an index for plotting:
    model_out <-  get_model_output(site=site, run= run, var = var,model_name=model_name, co2_levels = "412ppm")

    # extract the equilibrium phase, and use those years for the boxplot
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper
    eq <- model_out@data$Total[lower:upper]
    # need to add dots, because the variablility is so low in some models,
    #we don't see a colour, hence cannot distinguish between models.
    med<- mean(eq)
    if(model_name == models_avail[1]){
      plot(1:(lgth+1), rep(NA,lgth+1), ylim= c(0,ylim), xaxt = "n",
           yaxt = "n", yaxt = "n", xlab="", ylab="", xlim=c(1,lgth+1)) #prepare boxplot

      boxplot(eq, at = i, col=get_model_colour(model_name), add=TRUE,yaxt = "n")
      points(i, med, col=get_model_colour(model_name),cex=1.7,pch=16)

    }else{
      boxplot(eq, at = i, col=get_model_colour(model_name), add=TRUE,yaxt = "n")
      points(i,med, col=get_model_colour(model_name), pch=16,cex=1.7)
    }
   }

  #add mature forest observations:
  # Percentile ranking of values within each age bin (FIN) with 10th and 90th upper percentile boundary.
  # use all datapoints (regardless of upper or lower or median value) for the construction of the boxplot,
  # Unlike for the supplementaries, we no longer plot annual timeseries values, but treat all years as a piece of evidence for "an equilibrium" range.

    combined_data <- c(eq_dyn_obs[which(eq_dyn_obs$site == site),]$AGB_kgCm2,
                       eq_dyn_obs[which(eq_dyn_obs$site == site),]$AGB_upper_kgCm2,
                       eq_dyn_obs[which(eq_dyn_obs$site == site),]$AGB_lower_kgCm2)
    bp_stats     <- boxplot(combined_data,plot= FALSE)
    boxplot(at = 10,combined_data, add=TRUE,yaxt = "n")

    AGB_lower <- bp_stats$stats[1] #lower whisker
    AGB_upper <- bp_stats$stats[5] #upper whisker

   # Define x coordinates for the polygon (spanning across the models)
   x_coords <- c(0.5, length(models_avail) + 0.5, length(models_avail) + 0.5, 0.5)

   # Define y coordinates for the polygon (from lower to upper bounds)
   y_coords <- c(AGB_lower, AGB_lower, AGB_upper, AGB_upper)

   # Add grey background polygon before plotting the boxplots
   polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)

  if(site == "BCI"){
   axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
   axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
   axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)


   modelss <- c("JULES-RED"     ,    "FATES"       ,      "ORCHIDEE"         , "LPJ-GUESS"
               ,    "CABLE-POP"      ,   "BiomeEP"       ,    "BiomeE", "SEIB-DGVM"    ,     "EDv3" , "Observations")
   axis(labels=modelss,side=1,at=1:(length(models_avail)+1),las=2,cex=0.8)

  }else{
     axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     #axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }
  mtext(paste0(def(site)),adj=0.97,side=3,line=-1.1,cex = 0.8)

}


 par(fig=c(0,0.75,0.001,0.05), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    # add legend into FIN, there is the most space:
    legend(legend = c("BiomeE","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE"),
         lty= 1,lwd=2.3,
         col = c(get_model_colour("BiomeE-Standalone"),
                 get_model_colour("BiomeEP"),
                 get_model_colour("CABLE-POP"),
                 get_model_colour("FATES"),
                 get_model_colour("JULES-RED"),
                 get_model_colour("LPJ-GUESS"),
                 get_model_colour("EDv3"),
                 get_model_colour("SEIB-DGVM"),
                 get_model_colour("ORCHIDEE")),"center", ncol = 3, box.lwd = 0)

dev.off()



```

```{r supplementary_materials_regrowth_individual_model, eval=TRUE}
# single-model regrowth and mature equilibrium carbon content, in one single graph.
# the data are not aggregated, but are shown as their annual values, as was provided
# to the modellers alongside the simulation protocol


pdf(file=paste0(Figs_dir,"NotesS4_Benchmark_regrowth_per_model.pdf"))

var="AGcwood"
run  = "P0"

#load benchmark obs:
regrowth_obs <- read.csv(paste0(obs.path,"benchmark_regrowth_curves.csv"),head =TRUE)
eq_dyn_obs <- read.csv(paste0(obs.path,"benchmark_eq_dynamics.csv"),head =TRUE)

for( model_name in models_avail){
  print(model_name)
  par(mfcol=c(3,1),mar=c(1,3,1,1),oma=c(2,0.5,3,0.1),cex=0.8)
###############################################################
  for(site in sites){
  regrowth_benchmarks(model_name = model_name,site_in = site,var_in=var, regrowth_obs_in = regrowth_obs, eq_dyn_obs_in = eq_dyn_obs)
}

mtext(side=2,"AGcwood (kgC m-2)",line=-1,outer=TRUE)
mtext("Year",side =1, line =1, outer=TRUE)
mtext(model_name, side=3,outer=TRUE,cex=2)
}

plot.new()
legend(legend = c("Boreal obs.","Temperate obs.","Tropics obs."), pch = c(21,21,21),"center")
legend(legend = c("Boreal obs.","Temperate obs.","Tropics obs."), col = c("dark green","light green","brown"), pch = c("|","|","|"),"center",bty='n')

dev.off()

```

```{r regrowth_all_models_after_30_years_and_eq_biomass, eval=TRUE}

# Table S11 to highlight the large difference in Carbon content at the same timing of recovery, relative to each model's equilibrium value.
# -> hints at the different "initialisations"/establishments post-recovery
# add the growth rates, too, they are mentioned in the text of discussion and abstract.
# rendered as worddoc using Eckes-Shepahrd_et_al2025_create_supplementary_tables.Rmd and then further modified within word.

par(mar=c(0,2.5,0,0),oma=c(2.4,0.4,0.1,0.3),cex=0.8)

co2 = "412ppm"
last_sim_year = 450

# create new list of dfs to collect AGcwood after 30 years of regrowth:
AGcwood_30years <- data.frame(matrix(ncol = length(models_avail)+3, nrow = length(sites)))
colnames(AGcwood_30years) <- c(models_avail,"min","max","sites")
AGcwood_30years$sites <- sites
AGcwood_equilibrium <- AGcwood_30years

var = "AGcwood"
run = "P0"

#load models and calculate 10% of its mature state equilibrium biomass:
 for(site in sites){
   for(model_name in models_avail){

    #index for collection of data in eq_values:
    idx <- which(eq_values[[site]]$model== model_name )

    lower   <- eq_values[[site]][idx,]$lower
    upper   <- eq_values[[site]][idx,]$upper

    model_out <-  get_model_output(site=site, run= run, var = var,model_name=model_name, co2_levels = co2)

    eq_AGcwood <- mean(model_out@data$Total[lower:upper])

    model_out_regrowth <- omit_equilibrium_phase(model_out,model_name = model_name,site = site)

    # AGcwood after 30 years:
    AGcwood_30years[which(AGcwood_30years$sites==site),model_name] <- model_out_regrowth@data$Total[30]

    #AGcwood_equilibrium:
    AGcwood_equilibrium[which(AGcwood_equilibrium$sites==site),model_name] <- eq_AGcwood
   }
   #calculate minimum and maximum values for AGcwood after 30 years:
   AGcwood_30years[which(AGcwood_30years$sites==site),]$min <- min(AGcwood_30years[which(AGcwood_30years$sites==site),1:length(models_avail)],na.rm=TRUE)
   AGcwood_30years[which(AGcwood_30years$sites==site),]$max <- max(AGcwood_30years[which(AGcwood_30years$sites==site),1:length(models_avail)],na.rm=TRUE)

    #and at equilibrium 30 years:
   AGcwood_equilibrium[which(AGcwood_equilibrium$sites==site),]$min <- min(AGcwood_equilibrium[which(AGcwood_equilibrium$sites==site),1:length(models_avail)],na.rm=TRUE)
   AGcwood_equilibrium[which(AGcwood_equilibrium$sites==site),]$max <- max(AGcwood_equilibrium[which(AGcwood_equilibrium$sites==site),1:length(models_avail)],na.rm=TRUE)

 }
#now combine the tables here, or keep separate if wanted:

knitr::kable(AGcwood_30years,caption = "Aboveground woody carbon (AGcwood, KgC m2) after 30 years of disturbance recovery, by model and site.")


AGcwood_equilibrium$State <- "equilibrium"
AGcwood_30years$State <- "after 30 years regrowth"

combined <- rbind(AGcwood_equilibrium,AGcwood_30years)

knitr::kable(combined,caption = "Aboveground woody carbon (AGcwood, KgC m2) after 30 years of disturbance recovery, and at equilibrium, by model and site.")

```



## stand structure

```{r Figure4_benchmark_forest_structure_allmodels, eval=TRUE}

png(filename=paste0(Figs_dir,simdate,"/Figure4_Benchmark_stand_structure_allmodels.png"),width=150,height=150,units = "mm",res=960)

# stand structure: nstems and AGB (woody aboveground carbon), now called AGcwood

#load benchmark obs:
stand_structure_obs <- read.csv(paste0(obs.path,"benchmark_stand_structure.csv"),head =TRUE)
stand_structure_obs[which(stand_structure_obs$site =="FI"),]$site <- "FIN"
dbh_classes_plot <- stand_structure_obs[which(stand_structure_obs$site == "BCI"),]$dbh_classes_num # retrieve all possible bin classes


par(mfcol=c(3,2),mar=c(0,3,0,0),oma=c(3,0.5,0,0.3))


ylim_set = c(-7,7)
cex_model_points = 1


for(site in sites){

 #load and plot models:
 #nstem_size -logged
 var ="nstem_size"
 for(model_name in models_avail){
   print(model_name)

    if( model_name=="CABLE-POP"| model_name == "LPJ-GUESS"){
      run = "P1" # must use P1 simulations, because a little background disturbance must occur to reflect missing mortality processes in these models.
      # see discussion in supplementary. materials and chunk below
    }else{
      run = "P0" # use for other models, too.
    }
  model_out <-  get_model_output(site=site, run=run, var=var,model_name=model_name, co2_levels = "412ppm")

  if(model_name == models_avail[1]){
    plot(dbh_classes_plot[-1],
       log10(model_out@data[model_out@data$Year == max(model_out@data$Year),
                          c( "<5","<10","<15","<20","<30","<40","<50","<60","<70","<80","<90","<100","<150","<200",">=200")]),
       ylim = ylim_set ,col= get_model_colour(model_name),cex=cex_model_points, xaxt = "n", yaxt = "n",xlab="",ylab="",pch=16,type="p")
  }else{
    points(dbh_classes_plot,
       log10(model_out@data[model_out@data$Year == max(model_out@data$Year),
                          c( "<1","<5","<10","<15","<20","<30","<40","<50","<60","<70","<80","<90","<100","<150","<200",">=200")]),
       col= get_model_colour(model_name),pch=16,cex=cex_model_points, xaxt = "n", yaxt = "n",xlab="",ylab="")
  }
 }

  ## add observations:
  points(stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
         log10(stand_structure_obs[which(stand_structure_obs$site == site),]$nstem_size_ha.1),
         col= get_biome_colour(site,black_only=TRUE),lwd=2 )

  ### Highlight the different methods of aggregating the benchmark data:
  # FIN + BIA : use all annual plot-level values of sizeclass data that is available.
  # The sizeclasses are pooled across plots. Then percentile ranking is done
  biome <- biomes[which(sites==site)]
  if(biome== "Temperate"| biome =="Boreal"){ #all values used, median used
    arrows(stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
           log10(stand_structure_obs[which(stand_structure_obs$site == site),]$nstem_size_lower_ha.1),
           stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
           log10(stand_structure_obs[which(stand_structure_obs$site == site),]$nstem_size_upper_ha.1),
            length = 0.01, angle = 90, code = 3,
            col= get_biome_colour(site,black_only=TRUE),lwd=1 )
    }
  if(biome =="Tropics"){ # again, bootstrapping samples from 50 ha,plot, reporting median and 95% CI
     arrows(stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
           log10(stand_structure_obs[which(stand_structure_obs$site == site),]$nstem_size_lower_ha.1),
           stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
           log10(stand_structure_obs[which(stand_structure_obs$site == site),]$nstem_size_upper_ha.1),
            length = 0.01, angle = 90, code = 3,
            col= get_biome_colour(site,black_only=TRUE),lwd=1 ,lty=4)
  }
  mtext(paste0(abc(site)," ",site),adj=0.95,side=3,line=-1.3,cex=0.7)

  if(site == "BCI"){
     axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(1, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }else{
     axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }


  if(site=="BCI"){
    legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE"),
         #lty=rep(NA,7),lwd=rep(NA,7),pch=rep(16,7),
         #lty= 1,lwd=2,
         lty=rep(NA,0),pch=rep(16,9),
         col = c(get_model_colour("BiomeE-Standalone"),
                 get_model_colour("BiomeEP"),
                 get_model_colour("CABLE-POP"),
                 get_model_colour("FATES"),
                 get_model_colour("JULES-RED"),
                 get_model_colour("LPJ-GUESS"),
                 get_model_colour("EDv3"),
                 get_model_colour("SEIB-DGVM"),
                 get_model_colour("ORCHIDEE"))
                 ,"bottom",ncol=3,cex=0.78, bty = "n", box.col="white", bg="white" )


  }

}

mtext(side=2,expression(log(nstems)~(nstems~ha^-1)),line=-1.3,outer=TRUE)

####################################################################################


ylim_set = c(0,5)
var ="cwood_size"
for(site in sites){

   #load and plot models:
 for(model_name in models_avail){

  # !Note, applying a 0.75 factor to arrive at AGcwood_size; except for ORCHIDEE (see table )
  if(model_name=="ORCHIDEE"){roots_off=1.0}else{roots_off = 0.75}

      if( model_name=="CABLE-POP"| model_name == "LPJ-GUESS"){
      run = "P1" # must use P1 simulations, because a little background disturbance must occur to reflect stand processes in these models.
    }else{
      run = "P0" # use for other models, too.
    }

  model_out <-  get_model_output(site=site, run=run, var=var,model_name=model_name, co2_levels = "412ppm")

  if(model_name == models_avail[1]){
    plot(dbh_classes_plot[-1],
       model_out@data[model_out@data$Year == max(model_out@data$Year),
                      c( "<5","<10","<15","<20","<30","<40","<50","<60","<70","<80","<90","<100","<150","<200",">=200")]*roots_off,
       ylim = ylim_set ,col= get_model_colour(model_name),cex=cex_model_points, xaxt = "n", yaxt = "n",xlab="",ylab="",type="p",pch=16)
  }else{
    points(dbh_classes_plot,
       model_out@data[model_out@data$Year == max(model_out@data$Year),
                      c( "<1","<5","<10","<15","<20","<30","<40","<50","<60","<70","<80","<90","<100","<150","<200",">=200")]*roots_off,
      col= get_model_colour(model_name),pch=16,cex=cex_model_points, xaxt = "n", yaxt = "n",xlab="",ylab="")
  }
 }

    max_obs <- max( na.omit(stand_structure_obs[,c("AGB_size_kgCm.2","AGB_size_upper_kgCm.2","AGB_size_lower_kgCm.2")]) )


    points(stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,#[1:12],
           stand_structure_obs[which(stand_structure_obs$site == site),]$AGB_size_kgCm.2,#[1:12],
           col= get_biome_colour(site,black_only=TRUE),lwd = 2)
      ### Highlight the different methods of aggregating the benchmark data:
     # FIN + BIA : use all plot-level values of sizeclass data that is available. The sizeclasses are pooled across plots. Then percentile ranking is done
    biome <- biomes[which(sites==site)]
    if(biome== "Temperate"| biome =="Boreal"){ #all values used, median used
      arrows(stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
             stand_structure_obs[which(stand_structure_obs$site == site),]$AGB_size_lower_kgCm.2,#[1:12],
             stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
             stand_structure_obs[which(stand_structure_obs$site == site),]$AGB_size_upper_kgCm.2,#[1:12],
              length = 0.01, angle = 90, code = 3,
              col= get_biome_colour(site,black_only=TRUE),lwd = 1)
    }
    if(biome== "Tropics"){ #all values used, median used
    arrows(stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
           stand_structure_obs[which(stand_structure_obs$site == site),]$AGB_size_lower_kgCm.2,#[1:12],
           stand_structure_obs[which(stand_structure_obs$site == site),]$dbh_classes_num,
           stand_structure_obs[which(stand_structure_obs$site == site),]$AGB_size_upper_kgCm.2,#[1:12],
            length = 0.01, angle = 90, code = 3,
            col= get_biome_colour(site,black_only=TRUE),lwd = 1 ,lty=4)}

    mtext(paste0(def(site)," ",site),adj=0.95,side=3,line=-1.3,cex=0.7)

    if(site == "BCI"){
     axis(2, line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(1, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }else{
     axis(2, line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }

}


mtext(side=2,expression(AGcwood~(kgC~m^-2)),line=-24,outer=TRUE)
mtext(side=1,"dbh-class",line=1.5,outer=TRUE)


dev.off()


```

```{r supplementary_materials_benchmark_individual_model,eval=TRUE}

#plot individual models' performance against observations.

#load benchmark obs:
stand_structure_obs <- read.csv(paste0(obs.path,"benchmark_stand_structure.csv"),head =TRUE)
stand_structure_obs[which(stand_structure_obs$site =="FI"),]$site <- "FIN"
#stand_structure_benchmarks(model_name="LPJ-GUESS",site_in = site, takelog =TRUE, var_in="nstem_size", stand_structure_obs)

pdf(file=paste0(Figs_dir,simdate,"/NotesS3_Benchmark_stand_structure_per_model.pdf"))

for(model_name in models_avail){
  print(model_name)


  par(mfrow=c(3,3),mar=c(1,3,1,1),oma=c(2,0.5,3,0.1),cex=0.8)
  for(site in sites){


    if( model_name=="CABLE-POP"| model_name == "LPJ-GUESS"){
      run = "P1" # must use P1 simulations, because a little background disturbance must occur to reflect stand processes in these models.
    }else{
      run = "P0" # use for other models, too.
    }
    stand_structure_benchmarks(model_name = model_name, site_in = site, takelog = TRUE,  var_in = "nstem_size", ylim_ext = c(-2,10),stand_structure_obs_in = stand_structure_obs,run=run)
    stand_structure_benchmarks(model_name = model_name, site_in = site, takelog = FALSE, var_in = "nstem_size", ylim_ext = c(-2,400),stand_structure_obs_in = stand_structure_obs,run=run)
    stand_structure_benchmarks(model_name = model_name, site_in = site, takelog = TRUE,  var_in = "cwood_size", ylim_ext = c(0,6),stand_structure_obs_in = stand_structure_obs,run=run)

  }
  mtext(outer=TRUE,model_name,side=3,cex=2)
  mtext(outer=TRUE,"dbh-class (cm)",side=1,cex=1, line =1)
}


dev.off()


```

```{r supplementary_materials_benchmark_LPJ-GUESSmodel,eval=TRUE}

png(filename=paste0(Figs_dir,"/FigS13_Benchmark_stand_structure_LPJ-GUESS.png"),width=150,height=75,units = "mm",res=360)

#plot LPJG models' performance against observations, highlight P0 vs P1, conclude continuation with P1 for stand structure benchmarks, but highlight this in the Fig 2
# caption

par(mfrow=c(1,3),mar=c(1,3,1,1),oma=c(2,0.5,3,0.1),cex=0.8)

letters <- c("a", "b", "c", "d", "e", "f","g","h","i")

#load benchmark obs:
stand_structure_obs <- read.csv(paste0(obs.path,"benchmark_stand_structure.csv"),head =TRUE)
stand_structure_obs[which(stand_structure_obs$site =="FI"),]$site <- "FIN"
#stand_structure_benchmarks(model_name="LPJ-GUESS",site_in = site, takelog =TRUE, var_in="nstem_size", stand_structure_obs)


model_name = "LPJ-GUESS"
  plot_year=450

  i=1
  for(site in c("BCI")){

    if(model_name == "LPJ-GUESS"){
      run = "P0" # must use P1 simulations, because a little background disturbance must occur to reflect stand processes in these models.
    }
    ############
    var_in ="nstem_size"
    stand_structure_benchmarks(model_name = model_name, site_in = site, takelog = TRUE,  var_in = var_in,
                               ylim_ext = c(-2,10),stand_structure_obs_in = stand_structure_obs, run=run,
                               plot_site_name = FALSE, plot_year=plot_year)

    model_out <- get_model_output(site=site, run= "P1", var = var_in, model_name=model_name, co2_levels = "412ppm")
    points(dbh_classes_plot, log(model_out@data[model_out@data$Year == plot_year,
                              c( "<1" ,   "<5" ,   "<10", "<15",  "<20" ,  "<30",   "<40"  , "<50" ,  "<60" ,  "<70" ,  "<80" ,
                                 "<90" ,  "<100",  "<150" , "<200",  ">=200")]),
             ylim = ylim_set ,col= get_model_colour(model_name),pch=17,cex=1,ylab="",type="p")
     points(dbh_classes_plot, log(model_out@data[model_out@data$Year == plot_year,
                              c( "<1" ,   "<5" ,   "<10", "<15",  "<20" ,  "<30",   "<40"  , "<50" ,  "<60" ,  "<70" ,  "<80" ,
                                 "<90" ,  "<100",  "<150" , "<200",  ">=200")]),
           ylim = ylim_set ,col= "black",pch=2,cex=1,ylab="",type="p")

    mtext(paste0(letters[i],") ",site),adj=0.95,side=3,line=-1.3,cex=1)
    i=i+1

   ############
    var_in="nstem_size"
    stand_structure_benchmarks(model_name = model_name, site_in = site, takelog = FALSE, var_in = var_in,
                               ylim_ext = c(-2,400),stand_structure_obs_in = stand_structure_obs, run=run,
                               plot_site_name = FALSE, plot_year=plot_year)

    model_out <- get_model_output(site=site, run= "P1", var = var_in, model_name=model_name, co2_levels = "412ppm")
    points(dbh_classes_plot, model_out@data[model_out@data$Year == plot_year,
                              c( "<1" ,   "<5" ,   "<10", "<15",  "<20" ,  "<30",   "<40"  , "<50" ,  "<60" ,  "<70" ,  "<80" ,
                                 "<90" ,  "<100",  "<150" , "<200",  ">=200")],
             ylim = ylim_set ,col= get_model_colour(model_name),pch=17,cex=1,ylab="",type="p")
     points(dbh_classes_plot, model_out@data[model_out@data$Year == plot_year,
                              c( "<1" ,   "<5" ,   "<10", "<15",  "<20" ,  "<30",   "<40"  , "<50" ,  "<60" ,  "<70" ,  "<80" ,
                                 "<90" ,  "<100",  "<150" , "<200",  ">=200")],
           ylim = ylim_set ,col= "black",pch=2,cex=1,ylab="",type="p")

     mtext(paste0(letters[i],") ",site),adj=0.95,side=3,line=-1.3,cex=1)
    i=i+1
    ############


    ############
    var_in="cwood_size"
    stand_structure_benchmarks(model_name = model_name, site_in = site, takelog = TRUE,  var_in = var_in,
                               ylim_ext = c(0,4),stand_structure_obs_in = stand_structure_obs, run="P0",
                               plot_site_name = FALSE, plot_year = plot_year)
    model_out <- get_model_output(site=site, run= "P1", var = var_in, model_name=model_name, co2_levels = "412ppm")

    points(dbh_classes_plot, model_out@data[model_out@data$Year == plot_year,
                              c( "<1" ,   "<5" ,   "<10", "<15",  "<20" ,  "<30",   "<40"  , "<50" ,  "<60" ,  "<70" ,  "<80" ,
                                 "<90" ,  "<100",  "<150" , "<200",  ">=200")],
           ylim = ylim_set ,col= get_model_colour(model_name),pch=17,cex=1,ylab="",type="p")
    points(dbh_classes_plot, model_out@data[model_out@data$Year == plot_year,
                              c( "<1" ,   "<5" ,   "<10", "<15",  "<20" ,  "<30",   "<40"  , "<50" ,  "<60" ,  "<70" ,  "<80" ,
                                 "<90" ,  "<100",  "<150" , "<200",  ">=200")],
           ylim = ylim_set ,col= "black",pch=2,cex=1,ylab="",type="p")

   #add_stand_structure_benchmarks_summary(model_out,year_lower=300,year_upper=450)
   mtext(paste0(letters[i],") ",site),adj=0.95,side=3,line=-1.3,cex=1)
    i=i+1
  }

  mtext(outer=TRUE,model_name,side=3,cex=2)
  legend(legend=c("P0","P1"), "topleft",pch=c(16,17),col=rep(get_model_colour(model_name),2),bg="transparent",box.lwd = 0)
  legend(legend=c(NA,NA), "topleft",pch=c(NA,2),col="black",box.lwd = 0,bg="transparent")

dev.off()
```


## Self thinning

EDv3 used cmort-based mortality for evaluation of mortality rate thresholds.

cmort: (by sizeclass) Carbon Mass Flux lost from live wood due to mortality or other turnover Carbon Mass Flux lost from live wood due to mortality or other turnover process. (kgC m-2 yr-1)
cwood_size: Carbon mass in wood by size class (kgC m-2)
nstem_size: Stem number by size class (count ha-1)

Deviations: ORCHIDEE: AGcwood
```{r Supplementary_Materials_benchmarking_self_thinning,eval=TRUE}

# Self-thinning relationships should ideally be performed on Aboveground woody carbon (AGcwood), as is done in the observations, but we only have AGcwood output as total or per PFT.
# we could apply a factor on cwood_size, but a universal conversion factor on all models may be unfair, especially here, where allometry might have mattered in creating self-thinning behaviour in the model. So it is cleaner to stay with cwood_size, also for the mean individual biomass calculation that goes into the self-thinning slope creation.
# mortality rates are derived using total woody carbon (cwood) and total /a specific mortality woody carbon flux, because we consider more than AGcwood in the wood morality fluxes using AGcwood would bias the rates.

# using variables outputted by size-classes, we can also remove the smallest trees from the analysis, which are normally not accounted for in datasets used for self-thinning analysis (?!?!?!?)

# remember: the observations have been filtered for trees >10 dbh, and stand age > 10.

#now, to the same but plot all models in one plot:
pdf(file=paste0(Figs_dir,simdate,"/FigS11_Supplementary_materials_Benchmark_self_thinning_all_models_point_selection_methods_3plots.pdf"))

par(mfrow=c(4,3))
xlim_set = c(0,4)
ylim_set = c(-8,0)
point_cex = 0.4
sites <- c("FIN","BIA","BCI")

plot.new()

plot.new()

xmax = 410-33 # only do analysis on the original simulation length. Longer simulation periods mean that the selection of the 95th percentile (if applicable) of the mortality rate has a larger number of points to choose from, and also additional equilibrium forest dynamics that blurr the picture (especially in LPJG)
#-33 because the equilibrium period is already subtracted.

legend("center",legend=c( "self-thinning line","self-thinning period","output variable(s)"),lty=c(1,NA,NA), pch=c(NA,1,1), col=c("blue","red","black"))

plot.new()

legend("center",legend=c("method 1) > 95% thinning mort", "method 2) > 95% total mort",  "method 3) autoadjusted", "method 4) manually adjusted"), col=rep("white",3),cex=0.8, lty=c(1,1,1))

#data frame where I collect the manually adjusted upper and lower boundary of the indexes to derive the self-thinning line.


manual_adjustment = data.frame(models_avail =rep(x = models_avail,each=3), site = rep(sites,length(models_avail)))
manual_adjustment$upper <- NA
manual_adjustment$lower <- NA
manual_adjustment_empty <- manual_adjustment

manual_adjustment$mort_rate_name <- NA
manual_adjustment$identification_method <- NA


#EDv3

adjust_EDv3=FALSE


 manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "BCI"),]$upper <- as.numeric(55)#as.numeric(467) # period with peak nstem numbers
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "BCI"),]$lower <- as.numeric(31)#as.numeric(400)
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "BCI"),]$identification_method <- "4"

if(isTRUE(adjust_EDv3)){
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "BIA"),]$upper <- as.numeric(467) # upper boundary
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "BIA"),]$lower <- as.numeric(400)
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "BIA"),]$identification_method <- "4"
   manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "FIN"),]$upper <- as.numeric(110)#as.numeric(467) # upper boundary
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "FIN"),]$lower <- as.numeric(32)#as.numeric(400)
  manual_adjustment[which(manual_adjustment$models_avail == "EDv3"
                          & manual_adjustment$site == "FIN"),]$identification_method <- "4"

}



#ORCHIDEE
  mansel=FALSE

if(mansel){ # not used in paper:
    manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "FIN"),]$upper <-  as.numeric(410)#as.numeric(150) #as.numeric(450) # upper boundary
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "FIN"),]$lower <-  as.numeric(4)#as.numeric(50) #as.numeric(70)
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "FIN"),]$identification_method <- "4" # manual adjustment
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "BIA"),]$upper <-  as.numeric(20)#as.numeric(50) # upper boundary
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "BIA"),]$lower <- as.numeric(1)# as.numeric(150)
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "BIA"),]$identification_method <- "4" # manual adjustment
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "BCI"),]$upper <-  as.numeric(10)#as.numeric(100)
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "BCI"),]$lower <-  as.numeric(1)#as.numeric(60)
manual_adjustment[which(manual_adjustment$models_avail == "ORCHIDEE"
                        & manual_adjustment$site == "BCI"),]$identification_method <- "4" # manual adjustment
}


#SEIB-DGVM

#FIN: 50:80
#BIA: self-thinning. between sim year  41 :70
#BCI self-thinning:  31:50# done
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "BCI"),]$upper <- as.numeric(25) # 25 # upper boundary 231
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "BCI"),]$lower <- as.numeric(10) #8#32
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "BCI"),]$identification_method <- "4" # manual adjustment
#SEIB-DGVM
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "FIN"),]$upper <- as.numeric(100) #150 upper boundary 231
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "FIN"),]$lower <- as.numeric(50) ##32
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "FIN"),]$identification_method <- "4" # manual adjustment
#SEIB-DGVM
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "BIA"),]$upper <- as.numeric(150) # 150# upper boundary 231
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "BIA"),]$lower <- as.numeric(41) #90#32
manual_adjustment[which(manual_adjustment$models_avail == "SEIB-DGVM"
                        & manual_adjustment$site == "BIA"),]$identification_method <- "4" # manual adjustment

#FATES
manual_adjustment[which(manual_adjustment$models_avail == "FATES"
                        & manual_adjustment$site == "FIN"),]$upper <- as.numeric(290) # upper boundary 231
manual_adjustment[which(manual_adjustment$models_avail == "FATES"
                        & manual_adjustment$site == "FIN"),]$lower <- as.numeric(115) #32


#JULES-RED
#manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "FIN"),]$lower <- as.numeric(105)
#manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "FIN"),]$upper <- as.numeric(200)
manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "BIA"),]$lower <- as.numeric(55)
manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "BIA"),]$upper <- as.numeric(131)
manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "BIA"),]$identification_method <- "4" # manual adjustment

#manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "BCI"),]$lower <- as.numeric(50)
#manual_adjustment[which(manual_adjustment$models_avail == "JULES-RED" & manual_adjustment$site == "BCI"),]$upper <- as.numeric(131)

#manual_adjustment[which(manual_adjustment$models_avail == "BiomeEP" & manual_adjustment$site == "BIA"),]$lower <- as.numeric(190)
#manual_adjustment[which(manual_adjustment$models_avail == "BiomeEP" & manual_adjustment$site == "BIA"),]$upper <- as.numeric(220)
#manual_adjustment[which(manual_adjustment$models_avail == "BiomeEP" & manual_adjustment$site == "BIA"),]$identification_method <- "4" # manual adjustment


for(site in sites){

 #prepare dataframe that collects slopes and intercepts
 collect_stl <- data.frame(Mname=models_avail,STLslope =NA,STLint =NA,site= site)

  for (model_name in models_avail){
   #call model:
    # 1) call model
    # 2) update the "Total " value, since that is the total for all sizeclasses, but we exclude sizeclasses in indeces 4-6, below 10 dbh,
    # as this is often done in self-thinning studies.
    # 3) directly convert to dataframe, for easier to access data.
    MODEL_nstem   <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var="nstem_size",model_name=model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))

    #update to default simulation length -is model specific:
    xmax <- length(MODEL_nstem$Total)
    MODEL_nstem <-  MODEL_nstem[1:xmax,]

    if(model_name=="ORCHIDEE"){
      var="cwood_size"
      MODEL_agcwood <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var=var,model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))

      #update to default simulation length as per protocol:
      MODEL_agcwood <-  MODEL_agcwood[1:xmax,]
    }else{
      var="cwood_size"
      MODEL_agcwood <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var=var,model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))
      #update to default simulation length as per protocol:
      MODEL_agcwood <-  MODEL_agcwood[1:xmax,]
    }

    #LPJ-GUESS and FATES have a collection of mortality mechanisms that go beyond self-thinning,
    # e.g. _age(LPJ-GUESS) or _termination(FATES), and they lie somewhat outside the conventional self-thinning relationship.
    if(model_name=="LPJ-GUESS"){
      MODEL_mort_greff <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                   var="cmort_greff",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))

      #update to default simulation length
      MODEL_mort_greff <-  MODEL_mort_greff[1:xmax,]

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort <- data.frame(Year=MODEL_mort_greff$Year, Total = rep(NA,length(MODEL_mort_greff$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_greff$Total,MODEL_agcwood$Total)
      MODEL_mort$Total  <- MODEL_mort_greff$Total #calc_mort_rate_andrusetal2021(MODEL_mort_greff$Total,MODEL_nstem$Total)
      # MODEL_mort = NULL
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "1"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "greff"

    }else if(model_name =="FATES" & site != "FIN"){ #manual selection for FIN
      MODEL_mort <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="stemmort_cstarv",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))
     #MODEL_mort = NULL

      #update to default simulation length
      MODEL_mort <-  MODEL_mort[1:xmax,]

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "1"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "cstarv"


    }else if(model_name =="CABLE-POP"){
      # we cannot separate this by sizeclass, which is a bit problematic, but maybe it works anywyas, to show the crowding mechanism.
      MODEL_mort_crowd <- as.data.frame(get_model_output(site=site, run="P0",
                                     var="cmort_crowd",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),])

      # update to default simulation length
      MODEL_mort_crowd <-  MODEL_mort_crowd[1:xmax,]
      # as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_crowd$Year, Total = rep(NA,length(MODEL_mort_crowd$Total)))
      MODEL_mort$Total  <- MODEL_mort_crowd$Total #calc_mort_rate_andrusetal2021(MODEL_mort_crowd$Total,MODEL_agcwood$Total)
      # MODEL_mort = NULL

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "1"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "crowd"
    }else if(model_name =="EDv3" & site != "BCI"){ # manual adjustment at BCI

      MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="cmort_mort",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]) )

      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_size$Year, Total = rep(NA,length(MODEL_mort_size$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_size$Total,MODEL_agcwood$Total)

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "2"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "total"

      }else if(model_name =="BiomeE-Standalone" & site!="BIA"){
      #testing BiomeE-Standalone mortality rate ( does not distinguish between mortality rates, so probably not a good selector here?)
      #Actually: mortality rate seems to be a good selector, at least for BiomeE-Standalone ( more scattered for BiomeEP), but we cannot be 100% sure that this  mortality rate (potentially containing lots of other mortality processes besides self-thinning) indeed is dominated by self-thinning mortality.
      MODEL_nstem_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="cwood_size",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]) )
      MODEL_nstem_size <- MODEL_nstem_size[1:xmax,]
      MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="cmort_size",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]) )
      #update to default simulation length as per protocol:
      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_size$Year, Total = rep(NA,length(MODEL_mort_size$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_size$Total,MODEL_nstem_size$Total)

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "2"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "total"
    }else{
      MODEL_mort = NULL
      # method 3, semiautomatical choice of self-thinning.
    }

    #plot entire timeseries of model in "self thinning space"
    plot(log10(MODEL_nstem$Total),log10(MODEL_agcwood$Total/MODEL_nstem$Total),
            ylim=ylim_set,xlim=xlim_set,cex=point_cex,type="l",
    ylab="log(mean indiv. cwood) (KgC/m2)",xlab="log(nstem) (indiv/ha)", col="black")


    # not the entire regrowth period simulation is subject to self-thinning mechanisms,
    # must subset for the time where self thinning occurs, before fitting.
    # Here, I show what datapoints will be used in the thinning period

    # the slope:
    MODEL <- identify_thinning_period(agcwood = MODEL_agcwood$Total,
                            nstem=MODEL_nstem$Total,add_plot=FALSE,cmort=MODEL_mort$Total,
                            manual_adjustment[which(manual_adjustment$models_avail == model_name
                            & manual_adjustment$site == site),],model_name=model_name, site=site)
    MODEL_plot <- MODEL # for plotting later

    ############ ############ ############ ############ ############ ############
    ##rm some outliers which the different automatised approaches could not catch:

     if(site=="BIA" & model_name=="BiomeEP"){ #
      timepoints_rm_BIOMEEP = c(96:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]# select only the first self-thinning period, the algorithm caught too many.
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
     }

     # select only the first self-thinning period, the algorithm caught small incedences following regrowth.
      if( model_name=="LPJ-GUESS"){ #
      timepoints_rm_BIOMEEP = c(120:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }

      # select only the first self-thinning period, the algorithm caught small incedences following regrowth.
      if( model_name=="FATES" & site !="FIN"){ # FIN is manually selected
      timepoints_rm_BIOMEEP = c(120:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }

       # select only the first self-thinning period, the algorithm caught small incedences following regrowth.
      if( model_name=="EDv3"& site=="BIA"){ #
      timepoints_rm_BIOMEEP = c(100:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }

        # select only the first self-thinning period, the algorithm caught a longer stretch incedences following canopy closure
      if( model_name=="BiomeE-Standalone"& site=="BIA"){ #
      timepoints_rm_BIOMEEP = c(119:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }
    ############ ############ ############ ############ ############ ############

    ##fit the self-thinning line:
    m <- lm(MODEL[,2:1])
    points(MODEL[c(1,2)],col="red")

    collect_stl[which(collect_stl$Mname==model_name),]$STLslope <- m$coefficients[2]
    collect_stl[which(collect_stl$Mname==model_name),]$STLint   <- m$coefficients[1]

    #report on slope and method used to derive slope:
    mtext(paste("st-slope=", round(m$coefficients[2],digits = 3)),side=3 )

    #add self-thinning line to graph
    abline(lm(MODEL[,2] ~ MODEL[,1]),col= "blue" )


    #add information on whether the data points were  manually adjusted before creating the self-thinning line:
    if(is.na(manual_adjustment[which(manual_adjustment$models_avail == model_name
                           & manual_adjustment$site == site),]$identification_method)){
    # everything that is at this stage not categoriesed at the end was automatically adjusted (step 4).
    manual_adjustment[which(manual_adjustment$models_avail == model_name & manual_adjustment$site == site),]$identification_method <- "3"
    }
    n = manual_adjustment[which(manual_adjustment$models_avail == model_name & manual_adjustment$site == site),]$identification_method
    #report on slope and method used to derive slope:
    mtext(side=3,line=-4, paste("method",n))


    if(!is.null(MODEL_mort)){
      # fit the timeseries with the selected period:
      idx <- MODEL_plot$time
      plot(MODEL_mort$Year,MODEL_mort$Total, ylab= "mortality rate (% /yr)", xlab="year", main=paste(model_name,site))
      points(MODEL_mort[idx,]$Year, MODEL_mort[idx,]$Total,col="red")

      #to later calculate the self-thinning period length:
      lgth <- length(idx)
      manual_adjustment[which(manual_adjustment$models_avail == model_name & manual_adjustment$site == site),]$upper <- idx[lgth]
      manual_adjustment[which(manual_adjustment$models_avail == model_name & manual_adjustment$site == site),]$lower <- idx[1]

    }
    #for those models with manual adjustment, create the mortality timeseries here and then plot:
    if(is.null(MODEL_mort)){
       # retrieve timeseries now, for diagnosing where self-thinning points lie:
      if(model_name=="JULES-RED"){
      MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var="stemmort",model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:5)]))
      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      }else if(model_name =="BiomeEP"){

         MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var=var,model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))
      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      } else {
      # MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P1",
       #                                             var="stemmort",model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))
        if(model_name=="EDv3"){ var= "cmort_mort"}else{ var = "cmort"}
       MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var=var,model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),]))

      #update to default simulation length as per protocol:
      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      }

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_size$Year, Total = rep(NA,length(MODEL_mort_size$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_size$Total,MODEL_nstem$Total)
      # fit the timeseries with the selected period:
      idx <- MODEL_plot$time
      plot(MODEL_mort$Year,MODEL_mort$Total, ylab= "mortality rate (%  /yr)", xlab="year", main=paste(model_name,site))
      points(MODEL_mort[idx,]$Year, MODEL_mort[idx,]$Total,col="red")

      #to later calculate the self-thinning period length:
      lgth <- length(idx)
      manual_adjustment[which(manual_adjustment$models_avail == model_name & manual_adjustment$site == site),]$upper <- idx[lgth]
      manual_adjustment[which(manual_adjustment$models_avail == model_name & manual_adjustment$site == site),]$lower <- idx[1]

    }


    # plot the timeseries with the selected period:
    idx <- MODEL_plot$time

    plot(MODEL_agcwood$Year,MODEL_agcwood$Total, ylab= "cwood (KgC/m2)", xlab="year")
    points(MODEL_agcwood[idx,]$Year, MODEL_agcwood[idx,]$Total,col="red")
    legend("bottomright",legend=c("self-thinning period"),fill="red")

   rm(MODEL_mort) # reset to null, so that the thinning period can be correctly identified and the automated plots work in that function.
  #}

 collect_stl$site <-site
 collect_stl$co2 <- "412ppm"

  }
   #collect site-specific records, bring together ambient records:
     if(site=="FIN"){
      collect_final <- rbind(collect_stl)
     }else{
      coll  <- rbind(collect_stl)
      collect_final <- rbind(collect_final,coll)
     }

}

#mtext(side=2, "log(mean individual biomass)",line=,outer=TRUE)
#mtext(side=1,"log(nstem)",outer=TRUE,line=1)
dev.off()

# the mean ensemble time to self-thinning (because of the PPA approach,
# this does not necessarily correspond to closed-canopy,
# but it will be used in the conceptual diagram in the manuscript
# as anchor point for the timings
# mean(report_self_thinning[which(report_self_thinning$site=="BCI"),]$lower)
#29.44444
#mean(report_self_thinning[which(report_self_thinning$site=="BIA"),]$lower)
#39.55556
#mean(report_self_thinning[which(report_self_thinning$site=="FIN"),]$lower)
#52.77778


#in-text reporting of self-thinning durations:
#max(report_self_thinning[which(report_self_thinning$site=="BCI"& report_self_thinning$Model!="ORCHIDEE"),]$duration)

#max(report_self_thinning[which(report_self_thinning$site=="BIA"& report_self_thinning$Model!="ORCHIDEE"),]$duration)

#max(report_self_thinning[which(report_self_thinning$site=="FIN" & report_self_thinning$Model!="ORCHIDEE"),]$duration)


report_self_thinning <-merge(manual_adjustment,collect_final,by.x=c("models_avail","site"), by.y=c("Mname","site"))
report_self_thinning$co2 <- NULL
report_self_thinning$Self_thinning_duration <- report_self_thinning$upper - report_self_thinning$lower
names(report_self_thinning) <- c("Model","site","upper","lower","mort_mech","id_method","slope","intercept","duration")
knitr::kable(report_self_thinning[,c("Model","site","lower","upper","duration","id_method","slope")], caption="overview of method applied to identify self-thinning period. 1)from self-thinning-related mortality above 95th percentile of that mortality rate, 2) from total mortality above 95th percentile of total mortality rate, 3) automatic adjustment: selection of the consecutive points between the furthest to the bottom-left and the topright points in the timeseries in self-thining space, replicating the self-thinning trajectory. 4) manual adjustment: start and end were selected manually by eyeballing the points in self-thinning space and selecting those points that replicate the most a  self-thinning trajectory; STslope= self-thinning slope values. STint = self-thinning intercept values.")

```

repeat the above, now for the main text, with data:
```{r Figure_3_benchmark_self_thinning}

bitmap(file=paste0(Figs_dir,simdate,"/Figure3_self_thinning.png"),width=80,height=90,units="mm",res =1300,type="png16m")


#load benchmark data:
Conif <- read.csv(paste0(obs.path,"/Benchmark_Conif_Teo_self_thinning.csv"),head=TRUE)
Broadleaf  <- read.csv(paste0(obs.path,"/Benchmark_Broadleaf_Teo_self_thinning.csv"),head=TRUE)

xlim_set= c(0,5)
ylim_set= c(-8,0)

par(mfrow=c(2,2), mar=c(1,1,1,1), oma=c(2,2,0.1,0.1))

for(site in sites){

 #prepare dataframe that collects slopes and intercepts
 collect_stl <- data.frame(Mname=models_avail,STLslope =NA,STLint =NA,site= site)

  for (model_name in models_avail){

   #call model:
    # 1) call model
    # 2) update the "Total " value, since that is the total for all sizeclasses, but we exclude sizeclasses in indeces 4-6, below 10 dbh,
    # as this is often done in self-thinning studies.
    # 3) directly convert to dataframe, for easier to access data.
    MODEL_nstem   <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var="nstem_size",model_name=model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))

    #update to default simulation length -is model specific:
    xmax <- length(MODEL_nstem$Total)
    MODEL_nstem <-  MODEL_nstem[1:xmax,]

    if(model_name=="ORCHIDEE"){
      var="cwood_size"
      MODEL_agcwood <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var=var,model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))

      #update to default simulation length as per protocol:
      MODEL_agcwood <-  MODEL_agcwood[1:xmax,]
    }else{
      var="cwood_size"
      MODEL_agcwood <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                    var=var,model_name= model_name, co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))
      #update to default simulation length as per protocol:
      MODEL_agcwood <-  MODEL_agcwood[1:xmax,]
    }

    #LPJ-GUESS and FATES have a collection of mortality mechanisms that go beyond self-thinning,
    # e.g. _age(LPJ-GUESS) or _termination(FATES), and they lie somewhat outside the conventional self-thinning relationship.
    if(model_name=="LPJ-GUESS"){
      MODEL_mort_greff <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                                   var="cmort_greff",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))

      #update to default simulation length
      MODEL_mort_greff <-  MODEL_mort_greff[1:xmax,]

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort <- data.frame(Year=MODEL_mort_greff$Year, Total = rep(NA,length(MODEL_mort_greff$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_greff$Total,MODEL_agcwood$Total)
      MODEL_mort$Total  <- MODEL_mort_greff$Total #calc_mort_rate_andrusetal2021(MODEL_mort_greff$Total,MODEL_nstem$Total)
      # MODEL_mort = NULL
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "1"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "greff"

    }else if(model_name =="FATES"){
      MODEL_mort <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="stemmort_cstarv",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]))
     #MODEL_mort = NULL

      #update to default simulation length
      MODEL_mort <-  MODEL_mort[1:xmax,]

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "1"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "cstarv"


    }else if(model_name =="CABLE-POP"){
      # we cannot separate this by sizeclass, which is a bit problematic, but maybe it works anywyas, to show the crowding mechanism.
      MODEL_mort_crowd <- as.data.frame(get_model_output(site=site, run="P0",
                                     var="cmort_crowd",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),])

      # update to default simulation length
      MODEL_mort_crowd <-  MODEL_mort_crowd[1:xmax,]
      # as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_crowd$Year, Total = rep(NA,length(MODEL_mort_crowd$Total)))
      MODEL_mort$Total  <- MODEL_mort_crowd$Total #calc_mort_rate_andrusetal2021(MODEL_mort_crowd$Total,MODEL_agcwood$Total)
      # MODEL_mort = NULL

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "1"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "crowd"
    }else if(model_name =="EDv3" & site != "BCI"){ # manual adjustment at BCI

      MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="cmort_mort",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]) )

      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_size$Year, Total = rep(NA,length(MODEL_mort_size$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_size$Total,MODEL_agcwood$Total)

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "2"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "total"

      }else if(model_name =="BiomeE-Standalone" & site!="BIA"){
      #testing BiomeE-Standalone mortality rate ( does not distinguish between mortality rates, so probably not a good selector here?)
      #Actually: mortality rate seems to be a good selector, at least for BiomeE-Standalone ( more scattered for BiomeEP), but we cannot be 100% sure that this  mortality rate (potentially containing lots of other mortality processes besides self-thinning) indeed is dominated by self-thinning mortality.
      MODEL_nstem_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="cwood_size",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]) )
      MODEL_nstem_size <- MODEL_nstem_size[1:xmax,]
      MODEL_mort_size <- as.data.frame(update_total(get_model_output(site=site, run="P0",
                                     var="cmort_size",model_name=model_name,co2_levels = "412ppm")@data[-c(1:33),-c(4:6)]) )
      #update to default simulation length as per protocol:
      MODEL_mort_size <-  MODEL_mort_size[1:xmax,]

      #as percentage of total stand, and adhere to object type for subsequent use:
      MODEL_mort        <- data.frame(Year = MODEL_mort_size$Year, Total = rep(NA,length(MODEL_mort_size$Total)))
      MODEL_mort$Total  <- calc_mort_rate_andrusetal2021(MODEL_mort_size$Total,MODEL_nstem_size$Total)

      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$identification_method <- "2"
      manual_adjustment[which(manual_adjustment$models_avail==model_name & manual_adjustment$site==site),]$mort_rate_name <- "total"
    }else{
      MODEL_mort = NULL
      # method 3, semiautomatical choice of self-thinning.
    }

    # not the entire regrowth period simulation is subject to self-thinning mechanisms,
    # must subset for the time where self thinning occurs, before fitting.
    # Here, I show what datapoints will be used in the thinning period

    # the slope:
    MODEL <- identify_thinning_period(agcwood = MODEL_agcwood$Total,
                            nstem=MODEL_nstem$Total,add_plot=FALSE,cmort=MODEL_mort$Total,
                            manual_adjustment[which(manual_adjustment$models_avail == model_name
                            & manual_adjustment$site == site),],model_name=model_name, site=site)
    MODEL_plot <- MODEL # for plotting later

    ############ ############ ############ ############ ############ ############
    ##rm some outliers which the different automatised approaches could not catch:

     if(site=="BIA" & model_name=="BiomeEP"){ #
      timepoints_rm_BIOMEEP = c(96:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]# select only the first self-thinning period, the algorithm caught too many.
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
     }

     # select only the first self-thinning period, the algorithm caught small incedences following regrowth.
      if( model_name=="LPJ-GUESS"){ #
      timepoints_rm_BIOMEEP = c(120:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }

      # select only the first self-thinning period, the algorithm caught small incedences following regrowth.
      if( model_name=="FATES"){ #
      timepoints_rm_BIOMEEP = c(120:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }

       # select only the first self-thinning period, the algorithm caught small incedences following regrowth.
      if( model_name=="EDv3"& site=="BIA"){ #
      timepoints_rm_BIOMEEP = c(100:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }

        # select only the first self-thinning period, the algorithm caught a longer stretch incedences following canopy closure
      if( model_name=="BiomeE-Standalone"& site=="BIA"){ #
      timepoints_rm_BIOMEEP = c(119:MODEL$time[length(MODEL$time)])
      MODEL_plot <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      MODEL <- MODEL[which(!(MODEL$time %in% timepoints_rm_BIOMEEP)),]
      }
    ############ ############ ############ ############ ############ ############


    ##fit the self-thinning line:
    m <- lm(MODEL[,2:1])
    if(model_name ==models_avail[1]){

      if(site=="FIN"){
        plot(log10(Conif$trees.ha),log10(Conif$KgCm2/Conif$trees.ha),col= "light grey",pch=16 ,ylim=ylim_set,xlim=xlim_set,cex=0.6,
           ylab="log(mean indiv. cwood)",xlab="log(nstem)",xaxt="n")
        points(MODEL[c(1,2)],col=get_model_colour(model_name) ,ylim=ylim_set,xlim=xlim_set,cex=point_cex,
           ylab="log(mean indiv. cwood)",xlab="log(nstem)",xaxt="n")

          mtext(paste(abc(site),site),adj=0.02,side=3,line=-1.6)
      }
      if(site=="BIA"){
        plot(log10(Broadleaf$trees.ha),log10(Broadleaf$KgCm2/Broadleaf$trees.ha),col= "light grey",pch=16 ,ylim=ylim_set,xlim=xlim_set,cex=0.6,
           ylab="log(mean indiv. cwood)",xlab="log(nstem)",xaxt="n")
        points(MODEL[c(1,2)],col=get_model_colour(model_name) ,ylim=ylim_set,xlim=xlim_set,cex=point_cex,
           ylab="log(mean indiv. cwood)",xlab="log(nstem)",xaxt="n")

         mtext(paste(abc(site),site),adj=0.02,side=3,line=-1.6)
      }
      if(site=="BCI"){# no self-thinning data
         plot(MODEL[c(1,2)],col=get_model_colour(model_name) ,ylim=ylim_set,xlim=xlim_set,cex=point_cex,
           ylab="log(mean indiv. cwood)",xlab="log(nstem)",xaxt="n")
        mtext(paste(abc(site),site),adj=0.02,side=3,line=-1.6)
      }


    }else{
      points(MODEL[c(1,2)],col=get_model_colour(model_name))
    }

    }



   rm(MODEL_mort) # reset to null, so that the thinning period can be correctly identified and the automated plots work in that function.

    axis(1,  line = -0.6, lwd = 0)#, cex.axis = 0.9)
    axis(1, lwd = 1,labels = FALSE)


  }


mtext(side=2,"log(mean indiv. cwood)", outer=TRUE, line=1)
mtext("log(nstem)",outer=TRUE,adj=0.2,  side=1,line=1)


######add boxplots


  par(fig=c(6.5,12,0,6)/12)
  par(new=T)

 #create boxplot for only 412ppm
collect_final$site <- as.factor(collect_final$site)

boxplot(STLslope~site,collect_final, col = c(get_biome_colour("BCI"),get_biome_colour("BIA"),get_biome_colour("FIN") ), ylim=c(0,-3), ylab="", xlab="")
mtext(paste("d)"),adj=0.02,side=3,line=-1.6)

abline(h= -(3/2), col="grey", lwd=2) # Yoda et al
#abline(h= -1.24,  col="grey") # evidence 1:  (Comeau et al 2010, Pretsch 2005)
abline(h= -2.612, col="grey") # evidence 1:  (Pretsch 2005, Table 3)

#theoretical/ modelling evidence
abline(h= -1, lty=1,  col="grey") # evidence2: Mrad et al 2020
#abline(h= -2, lty=2,  col="grey") # evidence2: Mrad et al 2020

#add boxplot for on top of lines:
boxplot(STLslope~site,collect_final, col = c(get_biome_colour("BCI"),get_biome_colour("BIA"),get_biome_colour("FIN") ), ylim=c(0,-3), ylab="", xlab="", add=TRUE)
mtext(paste("d)"),adj=0.02,side=3,line=-1.6)


for(model_name in models_avail){
  #make sure FATES is located on "1"
  if(model_name=="FATES"){
    points(1, collect_final[which(collect_final$site=="BCI" & collect_final$Mname==model_name),"STLslope"],
           col = get_model_colour(model_name), pch=16)
  }else{
    points(jitter(1,2), collect_final[which(collect_final$site=="BCI" & collect_final$Mname==model_name),"STLslope"],
           col = get_model_colour(model_name), pch=16)
  }

  }
for(model_name in models_avail){
    points(jitter(2,2),collect_final[which(collect_final$site=="BIA" & collect_final$Mname==model_name),"STLslope"], col = get_model_colour(model_name), pch=16)
}
for(model_name in models_avail){
  points(jitter(3,1),collect_final[which(collect_final$site=="FIN" & collect_final$Mname==model_name),"STLslope"], col = get_model_colour(model_name), pch=16)
}


mtext("self-thinning slope", side=2, line =2)
legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE", "observations/theory"),
         lty=c(rep(NA,9),1),lwd=c(rep(NA,9),1),pch=c(rep(16,9),NA),
         col = c(get_model_colour("BiomeE-Standalone"),
                 get_model_colour("BiomeEP"),
                 get_model_colour("CABLE-POP"),
                 get_model_colour("FATES"),
                 get_model_colour("JULES-RED"),
                 get_model_colour("LPJ-GUESS"),
                 get_model_colour("EDv3"),
                 get_model_colour("SEIB-DGVM"),
                 get_model_colour("ORCHIDEE"),
                 "grey")
                 ,"bottom",ncol=2,cex=0.7, bty = "n", box.col="white", bg="white" )

dev.off()

table_out <- collect_final[which(collect_final$co2=="412ppm"),]
knitr::kable(table_out[,c("Mname","STLslope","site")],col.names=c("Model","STslope","Site"))

```



## turnover and growth
```{r Figure_5_turnover_and_growth}

png(file=paste0(Figs_dir,simdate,"/Figure5_eq_biomass_turnover_and_growth.png"),width=215,height=340,units="mm",res =300)

eq_dyn_obs <- read.csv(paste0(obs.path,"/benchmark_eq_dynamics.csv"),head =TRUE)
turnover_obs <- read.csv(paste0(obs.path,"/benchmark_turnover_times.csv"),head=TRUE) 
WBgrowth_obs <- read.csv(paste0(obs.path,"/benchmark_WBgrowth.csv"),head=TRUE) 

par(mfcol=c(3,3),mar=c(1,3,1,1),oma=c(2,0.5,3,0.1),cex=0.8)
####################################################################################
# Add a separate mature forest AGcwood boxplot:

for(site in sites){

   if(site=="FIN"){
    #par(fig=c(0.75,1,0.7,1), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
     ylim=20
  }
  if(site =="BIA"){
   # par(fig=c(0.75,1,0.40,0.70), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    ylim=20
  }
  if(site=="BCI"){
    #par(fig=c(0.75,1,0.1,0.40), oma=c(2,1,0.5,0.1), mar=c(0,2,0,0),new=TRUE)
    ylim=30
  }


  #prepare eq_dyn_obs for plotting on the same graph as regrowth:
  eq_dyn_obs <- eq_dyn_obs %>% group_by(site) %>% mutate(new_plot_loc = last_sim_year + (Year - max(Year)))


  #load and plot models, as boxplots:
    lgth <- length(models_avail)
   for(i in 1:lgth){
    model_name <- models_avail[i] # calling models this like this, because I need an index for plotting:
    model_out <-  get_model_output(site=site, run= run, var = var,model_name=model_name, co2_levels = "412ppm")

    # extract the equilibrium phase, and use those years for the boxplot
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper
    eq <- model_out@data$Total[lower:upper]
    # need to add dots, because the variablility is so low in som models,
    #we don't see a colour, hence cannot distinguish between models.
    med<- mean(eq)
    if(model_name == models_avail[1]){
      plot(1:(lgth+1), rep(NA,lgth+1), ylim= c(0,ylim), xaxt = "n",
           yaxt = "n", yaxt = "n", xlab="", ylab="", xlim=c(1,lgth+1)) #prepare boxplot

      boxplot(eq, at = i, col=get_model_colour(model_name), add=TRUE,yaxt = "n")
      points(i, med, col=get_model_colour(model_name),cex=1.7,pch=16)

    }else{
      boxplot(eq, at = i, col=get_model_colour(model_name), add=TRUE,yaxt = "n")
      points(i,med, col=get_model_colour(model_name), pch=16,cex=1.7)
    }
   }

  #add mature forest observations:
  # Percentile ranking of values within each age bin (FIN) with 10th and 90th upper percentile boundary.
  # use all datapoints (regardless of upper or lower or median value) for the construction of the boxplot,
  # Unlike for the supplementaries, we no longer plot annual timeseries values, but treat all years as a piece of evidence for "an equilibrium" range.

    combined_data <- c(eq_dyn_obs[which(eq_dyn_obs$site == site),]$AGB_kgCm2,
                       eq_dyn_obs[which(eq_dyn_obs$site == site),]$AGB_upper_kgCm2,
                       eq_dyn_obs[which(eq_dyn_obs$site == site),]$AGB_lower_kgCm2)
    bp_stats     <- boxplot(combined_data,plot= FALSE)
    boxplot(at = 10,combined_data, add=TRUE,yaxt = "n")

    AGB_lower <- bp_stats$stats[1] #lower whisker
    AGB_upper <- bp_stats$stats[5] #upper whisker

   # Define x coordinates for the polygon (spanning across the models)
   x_coords <- c(0.5, length(models_avail) + 0.5, length(models_avail) + 0.5, 0.5)

   # Define y coordinates for the polygon (from lower to upper bounds)
   y_coords <- c(AGB_lower, AGB_lower, AGB_upper, AGB_upper)

   # Add grey background polygon before plotting the boxplots
   polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)

  if(site == "BCI"){
   axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
   axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
   axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)


   modelss <- c("JULES-RED"     ,    "FATES"       ,      "ORCHIDEE"         , "LPJ-GUESS"
               ,    "CABLE-POP"      ,   "BiomeEP"       ,    "BiomeE", "SEIB-DGVM"    ,     "EDv3" , "Observations")
   axis(labels=modelss,side=1,at=1:(length(models_avail)+1),las=2,cex=0.8)

  }else{
     axis(2,  line = -0.6, lwd = 0, cex.axis = 0.9)
     axis(2, lwd = 1, cex.axis = 0.9,labels = FALSE,tck=-0.02)
     #axis(1, tck = 0.01 ,cex.axis = 0.8,labels = FALSE,tck=0.01)
  }
  mtext(paste0(abc(site)),adj=0.97,side=3,line=-1.1,cex = 0.8)

}


########### Barro Colorado Island:

par(mfcol=c(3,2),mar=c(0,3,0,0),oma=c(10,1,1,0))
#BCI - because there is no problem with leaves or with having to process Finland observations
model_pch = 16
#load observations:
#obs.dir <- "/Users/annemarie/Documents/1_TreeMort/2_Analysis/3_analysis_demographic_model_intercomparison/Outputs/outputs_observations/2_processed/"



######################## FIN
collect_turnover_FIN <- list()
site="FIN"
FIN_Turnover <- turnover_obs[grepl("^FIN\\.", turnover_obs$site), ]
names(FIN_Turnover) <- c("site","year","biomass_alive","mort_flux","turnover_time","mortality_rate")

for(model_name in models_avail){
  if(model_name=="CABLE-POP" | model_name=="LPJ-GUESS"){
    run="P0"
  }
  else{
    run="P0"
  }

    cmort_in   <- get_model_output(var="cmort",site=site,run=run,model_name=model_name, co2_levels = "412ppm")
    cwood_in   <- get_model_output(var="cwood",site=site,run=run,model_name=model_name, co2_levels = "412ppm")
    cwood      <- omit_equilibrium_phase(cwood_in,model_name = model_name,site=site,selection_by_year = TRUE)
    cmort      <- omit_equilibrium_phase(cmort_in,model_name = model_name,site=site,selection_by_year = TRUE)

    # extract the equilibrium phase, and use those years for the boxplot
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower-30
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper-30

    #calculate turnover time:
    turnover_time <- cwood@data$Total[lower:upper]/cmort@data$Total[lower:upper]

    collect_turnover_FIN[[model_name]] <- turnover_time

}

# prepare grey shaded area:
# Get lower and upper bounds for the specific site
bp_stats <- boxplot(c(FIN_Turnover$turnover_time),plot= FALSE)
lower <- bp_stats$stats[1] #lower whisker
upper <- bp_stats$stats[5] #upper whisker

# Define x coordinates for the polygon (spanning across the models)
x_coords <- c(0.5, length(models_avail) + 1.5, length(models_avail) + 1.5, 0.5)

# Define y coordinates for the polygon (from lower to upper bounds)
y_coords <- c(lower, lower, upper, upper)

collect_turnover_FIN$Obsplaceholder <-  NA
#prepare boxplot:
boxplot(at=1:10,matrix(ncol=10,NA),col = get_model_colour(models_avail),ylim=c(0,400), axes=FALSE, outcol = get_model_colour(models_avail) )
#add observational range:
polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)
#add to the boxplot the model output:
i=1
for(model_name in models_avail){
     boxplot(at=i,collect_turnover_FIN[[model_name]],col = get_model_colour(model_name),ylim=c(0,1400), axes=FALSE, outcol = get_model_colour(model_name) ,add=TRUE)
     i=i+1 # next model position
}
rm_dot <- c(2,4,8) # some models have large boxplots, so don't need dots for identification by colour
boxplot_md <- sapply(collect_turnover_FIN,median) # get boxplot horizontal line (= mean) for plotting of models that don't have a wide spread
points(c(1:10)[-rm_dot],boxplot_md[-rm_dot] ,col = get_model_colour(models_avail[-rm_dot]),pch=model_pch,cex=1.4)
boxplot(at=10,na.omit(c(FIN_Turnover$turnover_time)),ylim=c(0,1.7), axes=FALSE,add = TRUE,col="gray34") #observations
#add number of samples:
text(x = 10, y = upper + 0.1 * upper, labels = paste("n =", bp_stats$n[1]), cex = 0.8)


axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(side=2,tick = F,line = -0.7)#,at=c(420,430,440,450))
axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
box()
#NB:plotting the "raw" output of ORCHIDEE is probably not fair? should I plot the mean as a line?


#mtext(side=3,line=-1,adj=0.9,paste0(site))
axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
mtext(paste0(abc(site)),adj=0.02,side=3,line=-1.4)

########################BIAlovieza
site="BIA"
BIA_Turnover <- turnover_obs[grepl("^NHR.bial\\.", turnover_obs$site), ]
names(BIA_Turnover) <- c("site","year","biomass_alive","mort_flux","turnover_time_yr","mortality_rate")

#eq_mort_length=31
#collect_turnover_BIA <- as.data.frame(matrix(ncol=length(models_avail),nrow=eq_mort_length+1))
#names(collect_turnover_BIA) <- models_avail
collect_turnover_BIA <- list()

for(model_name in models_avail){
  if(model_name=="CABLE-POP" | model_name=="LPJ-GUESS"){
    run="P0"
  }
  else{
    run="P0"
  }
  if(model_name=="BiomeE-Standalone"){
    cwood_var="cwood_size" # problem with cwood.nc file, but can use the cwood_size
  }else{
    cwood_var="cwood"
  }
    cmort_in    <- get_model_output(var="cmort",site=site,run=run,model_name=model_name, co2_levels = "412ppm")
    cwood_in   <- get_model_output(var=cwood_var,site=site,run=run,model_name=model_name, co2_levels = "412ppm")
    cwood    <- omit_equilibrium_phase(cwood_in,model_name = model_name,site=site,selection_by_year = TRUE)
    cmort    <- omit_equilibrium_phase(cmort_in,model_name = model_name,site=site,selection_by_year = TRUE)

     # extract the equilibrium phase, and use those years for the boxplot
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower-30
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper-30

    turnover_time <- cwood@data$Total[lower:upper]/cmort@data$Total[lower:upper]

    collect_turnover_BIA[[model_name]] <- turnover_time

}


#boxplot:
#prepare grey shaded area:
# Get lower and upper bounds for the specific site
bp_stats <- boxplot(c(BIA_Turnover$turnover_time_yr),plot= FALSE)
lower <- bp_stats$stats[1] #lower whisker
upper <- bp_stats$stats[5] #upper whisker

# Define x coordinates for the polygon (spanning across the models)
x_coords <- c(0.5, length(models_avail) + 1.5, length(models_avail) + 1.5, 0.5)

# Define y coordinates for the polygon (from lower to upper bounds)
y_coords <- c(lower, lower, upper, upper)

collect_turnover_BIA$Obsplaceholder <-  NA

#prepare boxplot:
boxplot(at=1:10,matrix(ncol=10,NA),col = get_model_colour(models_avail),ylim=c(0,160), axes=FALSE, outcol = get_model_colour(models_avail) )
#add observational range:
polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)
#add to the boxplot the model output:
i=1
for(model_name in models_avail){
     boxplot(at=i,collect_turnover_BIA[[model_name]],col = get_model_colour(model_name),ylim=c(0,100), axes=FALSE, outcol = get_model_colour(model_name) ,add=TRUE)
     i=i+1 # next model position
}
rm_dot <- c(2,4,8) # some models have large boxplots, so don't need dots for identification by colour
boxplot_md <- sapply(collect_turnover_BIA,median) # get boxplot horizontal line (= mean) for plotting of models that don't have a wide spread
points(c(1:10)[-rm_dot],boxplot_md[-rm_dot] ,col = get_model_colour(models_avail[-rm_dot]),pch=model_pch,cex=1.4)
boxplot(at=10,na.omit(c(BIA_Turnover$turnover_time_yr)),ylim=c(0,1.7), axes=FALSE,add = TRUE,col="gray34") #observations
#add number of samples:
text(x = 10, y = upper + 0.1 * upper, labels = paste("n =", bp_stats$n[1]), cex = 0.8)


axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(side=2,tick = F,line = -0.7)#,at=c(420,430,440,450))
axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
box()
mtext(paste0(abc(site)),adj=0.01,side=3,line=-1.4)
########################


######################## BCI
site="BIA"
BCI_Turnover <- turnover_obs[grepl("^BCI", turnover_obs$site), ]
names(BCI_Turnover) <- c("site","year","biomass_alive","mort_flux","turnover_time","mortality_rate")
var  = "cmort"
run  = "P0" # note: differs for LPJ-GUESS and CABLE-POP




#the equilibrium periods between models are differently long, I collect them in a list of vectors:
collect_turnover_BCI <- list()

for(model_name in models_avail){
  if(model_name=="CABLE-POP" | model_name=="LPJ-GUESS"){
    run="P0"
  }
  else{
    run="P0"
  }
    cmort_in    <- get_model_output(var="cmort",site=site,run=run,model_name=model_name, co2_levels = "412ppm")
    cwood_in   <- get_model_output(var="cwood",site=site,run=run,model_name=model_name, co2_levels = "412ppm")
    cwood    <- omit_equilibrium_phase(cwood_in,model_name = model_name,site=site,selection_by_year = TRUE)
    cmort    <- omit_equilibrium_phase(cmort_in,model_name = model_name,site=site,selection_by_year = TRUE)

    # extract the equilibrium phase, and use those years for the boxplot
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower-30
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper-30

    turnover_time <- cwood@data$Total[lower:upper]/cmort@data$Total[lower:upper]

    # collect turnover values, used in boxplot
    collect_turnover_BCI[[model_name]] <- turnover_time
}

#prepare boxplot
#prepare grey shaded area:
# Get lower and upper observational bounds for the specific site
bp_stats <- boxplot(BCI_Turnover$turnover_time_yr,plot= FALSE)
lower <- bp_stats$stats[1] #lower whisker
upper <- bp_stats$stats[5] #upper whisker


# Define x coordinates for the polygon (spanning across the models)
x_coords <- c(0.5, length(models_avail) + 1.5, length(models_avail) + 1.5, 0.5)

# Define y coordinates for the polygon (from lower to upper bounds)
y_coords <- c(lower, lower, upper, upper)

collect_turnover_BCI$Obsplaceholder <-  NA

#prepare boxplot:
boxplot(at=1:10,matrix(ncol=10,NA),col = get_model_colour(models_avail),ylim=c(0,140), axes=FALSE, outcol = get_model_colour(models_avail) )
#add observational range:
polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)
#add to the boxplot the model output:
i=1
for(model_name in models_avail){
     boxplot(at=i,collect_turnover_BCI[[model_name]],col = get_model_colour(model_name),ylim=c(0,100), axes=FALSE, outcol = get_model_colour(model_name) ,add=TRUE)
     i=i+1 # next model position
}

#border=get_model_colour(models_avail)
rm_dot <- c(2,4,8) # some models have large boxplots, so don't need dots for identification by colour
boxplot_md <- sapply(collect_turnover_BCI,median,na.rm=TRUE) # get boxplot horizontal line (= mean) for plotting of models that don't have a wide spread
points(c(1:10)[-rm_dot],boxplot_md[-rm_dot] ,col = get_model_colour(models_avail[-rm_dot]),pch=model_pch,cex=1.4)
boxplot(at=10,c(BCI_Turnover$turnover_time_yr),ylim=c(0,1.7), axes=FALSE,add = TRUE,col="gray34") #observations
#add number of samples:
text(x = 10, y = upper + 0.1 * upper, labels = paste("n =", bp_stats$n[1]), cex = 0.8)

box()
#mtext(side=3,line=-1,adj=0.9,paste0(site))
axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(side=2,tick = F,line = -0.7)#,at=c(420,430,440,450))
axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
mtext(paste0(abc(site)),adj=0.01,side=3,line=-1.4)

########################


########################################################################
#Final plot aesthetics for first column:

 modelss <- c("JULES-RED"     ,    "FATES"       ,      "ORCHIDEE"         , "LPJ-GUESS"
               ,    "CABLE-POP"      ,   "BiomeEP"       ,    "BiomeE", "SEIB-DGVM"    ,     "EDv3" , "Observations")
   axis(labels=modelss,side=1,at=1:(length(models_avail)+1),las=2,cex=1.2)

mtext(side=2,"turnover time (years)",line=-1, outer =TRUE)


########################################################################


########################################################################
#WBgrowth benchmark:

ylim_wbgrowth =c(0,1.3)

########################Finland
site = "FIN"

benchmark_WBgrowth <- read.csv(paste0(obs.path,"benchmark_WBgrowth.csv"))
FIN <- benchmark_WBgrowth[which(benchmark_WBgrowth$site =="FIN"),]


# model output:
collect_boxplot_growth_FIN <- list()

for(model_name in models_avail){
  collect_boxplot_growth_FIN[[model_name]] <- benchmark_WBgrowth_flux(model_name=model_name,site=site,eq_values_in = eq_values)
}

#boxplot:
#prepare grey shaded area:
# Get lower and upper bounds for the specific site
bp_stats <- boxplot(FIN$WBgrowth_kgC_m2_yr,plot= FALSE)
lower <- bp_stats$stats[1] #lower whisker
upper <- bp_stats$stats[5] #upper whisker

# Define x coordinates for the polygon (spanning across the models)
x_coords <- c(0.5, length(models_avail) + 1.5, length(models_avail) + 1.5, 0.5)

# Define y coordinates for the polygon (from lower to upper bounds)
y_coords <- c(lower, lower, upper, upper)

collect_boxplot_growth_FIN$Obsplaceholder <-  NA
#prepare boxplot:
boxplot(at=1:10,matrix(ncol=10,NA),col = get_model_colour(models_avail),ylim=ylim_wbgrowth, axes=FALSE, outcol = get_model_colour(models_avail) )
#add observational range:
polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)
#add model output again, to have observational range shade in the background:
#add to the boxplot the model output:
i=1
for(model_name in models_avail){
     boxplot(at=i,collect_boxplot_growth_FIN[[model_name]],col = get_model_colour(model_name),ylim=c(0,100), axes=FALSE, outcol = get_model_colour(model_name) ,add=TRUE)
     i=i+1 # next model position
}

rm_dot <- c(2,4,8) # some models have large boxplots, so don't need dots for identification by colour
boxplot_md <- sapply(collect_boxplot_growth_FIN,median) # get boxplot horizontal line (= mean) for plotting of models that don't have a wide spread
points(c(1:10)[-rm_dot],boxplot_md[-rm_dot] ,col = get_model_colour(models_avail[-rm_dot]),pch=model_pch,cex=1.4)
boxplot(at=10,na.omit(c(FIN$WBgrowth_kgC_m2_yr)),ylim=c(0,1.7), axes=FALSE,add = TRUE,col="gray34") #observations
#add number of samples:
text(x = 10, y = upper + 0.1 * upper, labels = paste("n = ", bp_stats$n[1]), cex = 0.8)


axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(side=2,tick = F,line = -0.7)#,at=c(420,430,440,450))
axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
box()
mtext(paste0(def(site)),adj=0.01,side=3,line=-1.4)

#BIAlovieza
#################

# TMT data
BIA <- benchmark_WBgrowth[which(benchmark_WBgrowth$site =="BIA"),]

site = "BIA"

# model output:
collect_boxplot_growth_BIA <- list()
for(model_name in models_avail){
  collect_boxplot_growth_BIA[[model_name]] <- benchmark_WBgrowth_flux(model_name=model_name,site=site,eq_values_in = eq_values)
}

#boxplot:
#prepare grey shaded area:
# Get lower and upper bounds for the specific site
bp_stats <- boxplot(BIA$WBgrowth_kgC_m2_yr,plot= FALSE)
lower <- bp_stats$stats[1] #lower whisker
upper <- bp_stats$stats[5] #upper whisker

# Define x coordinates for the polygon (spanning across the models)
x_coords <- c(0.5, length(models_avail) + 1.5, length(models_avail) + 1.5, 0.5)

# Define y coordinates for the polygon (from lower to upper bounds)
y_coords <- c(lower, lower, upper, upper)


collect_boxplot_growth_BIA$Obsplaceholder <-  NA
boxplot(at=1:10,matrix(ncol=10,NA),col = get_model_colour(models_avail),ylim=ylim_wbgrowth, axes=FALSE, outcol = get_model_colour(models_avail) )
#add observational range:
polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)
#add model output again, to have observational range shade in the background:
#add to the boxplot the model output:
i=1
for(model_name in models_avail){
     boxplot(at=i,collect_boxplot_growth_BIA[[model_name]],col = get_model_colour(model_name),ylim=c(0,100), axes=FALSE, outcol = get_model_colour(model_name) ,add=TRUE)
     i=i+1 # next model position
}
rm_dot <- c(2,4,8) # some models have large boxplots, so don't need dots for identification by colour
boxplot_md <- sapply(collect_boxplot_growth_BIA,median) # get boxplot horizontal line (= mean) for plotting of models that don't have a wide spread
points(c(1:10)[-rm_dot],boxplot_md[-rm_dot] ,col = get_model_colour(models_avail[-rm_dot]),pch=model_pch,cex=1.4)
boxplot(at=10,na.omit(c(BIA$WBgrowth_kgC_m2_yr)), axes=FALSE,add = TRUE,col="gray34") #observations
mtext(side=2,"eq. growth flux (kgC m-2 yr-1)",line=1.6)
boxplot(at=10,na.omit(c(BIA$WBgrowth_kgC_m2_yr)),ylim=c(0,1.7), axes=FALSE,add = TRUE,col="gray34") #observations
#add number of samples:
text(x = 10, y = upper + 0.1 * upper, labels = paste("n =", bp_stats$n[1]), cex = 0.8)


axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(side=2,tick = F,line = -0.7)#,at=c(420,430,440,450))
axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
box()
mtext(paste0(def(site)),adj=0.01,side=3,line=-1.4)



##########BCI
BCI <- benchmark_WBgrowth[which(benchmark_WBgrowth$site =="BCI"),]

var  = "WBgrowth"
run  = "P0" # note: differs for LPJG and CABLE-POP
site = "BCI"
# model output:
collect_boxplot_growth_BCI <- list()
for(model_name in models_avail){
  collect_boxplot_growth_BCI[[model_name]] <- benchmark_WBgrowth_flux(model_name=model_name,site=site,eq_values_in = eq_values)
}

#boxplot:
#prepare grey shaded area:
# Get lower and upper bounds for the specific site
lower <- min(BCI$WBgrowth_kgC_m2_yr,na.rm = TRUE)
upper <- max(BCI$WBgrowth_kgC_m2_yr,na.rm = TRUE)

# Define x coordinates for the polygon (spanning across the models)
x_coords <- c(0.5, length(models_avail) + 1.5, length(models_avail) + 1.5, 0.5)

# Define y coordinates for the polygon (from lower to upper bounds)
y_coords <- c(lower, lower, upper, upper)


collect_boxplot_growth_BCI$Obsplaceholder <-  NA
boxplot(at=1:10,matrix(ncol=10,NA),col = get_model_colour(models_avail),ylim=ylim_wbgrowth, axes=FALSE, outcol = get_model_colour(models_avail) )
#add observational range:
polygon(x_coords, y_coords, col=adjustcolor("grey", alpha.f=0.2), border=NA)
#add model output again, to have observational range shade in the background:
#add to the boxplot the model output:
i=1
for(model_name in models_avail){
     boxplot(at=i,collect_boxplot_growth_BCI[[model_name]],col = get_model_colour(model_name),ylim=c(0,100), axes=FALSE, outcol = get_model_colour(model_name) ,add=TRUE)
     i=i+1 # next model position
}

rm_dot <- c(2,4,8) # some models have large boxplots, so don't need dots for identification by colour
boxplot_md <- sapply(collect_boxplot_growth_BCI,median) # get boxplot horizontal line (= mean) for plotting of models that don't have a wide spread
points(c(1:10)[-rm_dot],boxplot_md[-rm_dot] ,col = get_model_colour(models_avail[-rm_dot]),pch=model_pch,cex=1.4)
boxplot(at=10,na.omit(c(BCI$WBgrowth_kgC_m2_yr)), axes=FALSE,add = TRUE,col="gray34") #observations
#add number of samples:
text(x = 10, y = upper + 0.1 * upper, labels = paste("n =", bp_stats$n[1]), cex = 0.8)


axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(side=2,tick = F,line = -0.7)#,at=c(420,430,440,450))
axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
box()
mtext(paste0(def(site)),adj=0.01,side=3,line=-1.4)






 modelss <- c("JULES-RED"     ,    "FATES"       ,      "ORCHIDEE"         , "LPJ-GUESS"
               ,    "CABLE-POP"      ,   "BiomeEP"       ,    "BiomeE", "SEIB-DGVM"    ,     "EDv3" , "Observations")
   axis(labels=modelss,side=1,at=1:(length(models_avail)+1),las=2,cex=1.5)

par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")

legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE","Observations"),
       pch = c(rep(16,length(models_avail)),c(16)),
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("EDv3"),
               get_model_colour("SEIB-DGVM"),
               get_model_colour("ORCHIDEE"),1),
       "bottom",ncol=6,box.lwd = 0,inset = c(0,
    0))

mtext(outer =TRUE, "FIN", side=3, adj=0.01, line=-4)
mtext(outer =TRUE, "BIA", side=3, adj=0.01, line=-32)
mtext(outer =TRUE, "BCI", side=3, adj=0.01, line=-65)

dev.off()


```


# forest phase identification
used for manual alignment of cmort and Wbgrowth, in preparation for Figure 2
```{r forest_regrowth_phase_identification_for_alignment_1}
# these plots  are part of the powerpoint slides, submitted as Notes S2

n=200
smoothing=FALSE

# also create all dfs to collect the size of stems at establishment (up to 10 cm dbh, and then 10 and 15 dbh)
nstem_size_estab_upto10 <- data.frame(matrix(ncol = length(models_avail)+3, nrow = length(sites)))
colnames(nstem_size_estab_upto10) <- c(models_avail,"min","max","sites")
nstem_size_estab_upto10$sites <- sites
nstem_size_estab_10plus <- nstem_size_estab_upto10

#pdf(file=paste0(Figs_dir,simdate,"/Notes_S2_prep_forest_phase_identification.pdf"),width=8,height=8)
#models_sub <- models_avail[-2]
for(model_name in models_avail){
# cveg_total with Bgrowth and cmort.
# model_name="BiomeEP"

for (site in sites){

  if(model_name=="FATES"){# has also non-woody turnover as part of cmort
    if(model_name=="FATES"){var="stemmort"}else{var="stemmort_size"}
    #note FATES now actually uses stemmort and nstem to derive %rate, because maybe that is more meaningful
    cmort      <- get_model_output(site=site, run="P0",var=  var ,model_name=model_name, co2_levels = "412ppm")
    cmort@data <- cmort@data[1:n,] # shorten timeperiod, we are for now just interested in regrowth phase
    cveg       <- get_model_output(site=site, run="P0",var= "nstem_size",model_name=model_name, co2_levels = "412ppm")

    #omit grasses and update total:
    #cveg@data$Grasses <- 0.0
    #cveg@data$Total   <- rowSums(cveg@data[,c(4:11)])
    cveg@data <- cveg@data[1:n,]
    cmort_rate <- create_mort_rate(cmort,cveg, var_in = "stemmort_rate") # operates on total only


  }else{
    cmort      <- get_model_output(site=site, run="P0",var= "cmort",model_name=model_name, co2_levels = "412ppm")
    cmort@data <- cmort@data[1:n,] # shorten timeperiod, we are for now just interested in regrowth phase
   if(model_name=="BiomeEP"){var="cwood"}else{var="cwood_size"}
    cwood      <- get_model_output(site=site, run="P0",var= var,model_name=model_name, co2_levels = "412ppm")
    cwood@data <- cwood@data[1:n,]
    cmort_rate <- create_mort_rate(cmort,cwood, var_in = "cmort_rate") # operates on total only
   # plotTemporal(cmort_rate)
  }


cmort_rate_regrowth <- omit_equilibrium_phase(data_object = cmort_rate,site = site,model_name = model_name,selection_by_year = TRUE)
#smoothing =TRUE
if(smoothing){
  cmort_rate_regrowth <- create_rolling_means(var_to_plot =
                                            cmort_rate_regrowth,k=30,total_only=TRUE,
                                            align="left",rm_firstX_years=NULL)
}

cmort_rate_regrowth_mean_p <- plotTemporal(cmort_rate_regrowth,layers = c("Total"),subtitle = NULL, title = paste0("Mortality rate (",cmort_rate@quant@id,")"),y.label = "wood or stems lost due to mortality (% yr-1)")


nstem_size <- get_model_output(site=site, run="P0",var= "nstem_size",model_name=model_name, co2_levels = "412ppm")


nstem_size@data <- nstem_size@data[1:n, ]
nstem_size_regrowth <- omit_equilibrium_phase(data_object = nstem_size,site = site,model_name = model_name,selection_by_year = TRUE)

#select smaller than 10 and larger than 10 dbh classes to see where models start their establishment.
# some models don't resolve <1, account for this:
dbhcl <- c("<1","<5")
sel<- dbhcl %in% names(nstem_size_regrowth@data)
if(model_name=="JULES-RED"|model_name =="FATES"){
  nstem_size_estab_upto10[which(nstem_size_estab_upto10$sites==site),model_name] <- sum(nstem_size_regrowth@data[2,   c("<5","<10")])

}else{
  nstem_size_estab_upto10[which(nstem_size_estab_upto10$sites==site),model_name] <- sum(nstem_size_regrowth@data[2,   c("<1","<5","<10")])

}


nstem_size_estab_10plus[which(nstem_size_estab_10plus$sites==site),model_name] <- nstem_size_regrowth@data[2,   c("<15")]


# for plotting of the timeseries, select only the young/small trees
if(model_name =="JULES-RED" |model_name =="FATES"){ # no trees <1 in JULES
  nstem_size_regrowth@data <- nstem_size_regrowth@data[, c( "Year",  "Lat"  ,  "Lon","<5","<10","<15","Total")]
  names(nstem_size_regrowth@data) <- c( "Year",  "Lat"  ,  "Lon", "sdlg<5", "saplg<10", "saplg<15","Total")
}else{
  nstem_size_regrowth@data <- nstem_size_regrowth@data[, c( "Year",  "Lat"  ,  "Lon","<1","<5","<10","<15","Total")]
  names(nstem_size_regrowth@data) <- c( "Year",  "Lat"  ,  "Lon","sdlg<1", "sdlg<5", "saplg<10", "saplg<15","Total")
}




if(smoothing){
  nstem_size_regrowth <- create_rolling_means(var_to_plot =
                                                  nstem_size_regrowth,k=30,total_only=TRUE,
                                                   align="left",rm_firstX_years=NULL)
}

if(model_name =="JULES-RED"|model_name =="FATES"){
  nstem_size_regrowth_mean_p <- plotTemporal(nstem_size_regrowth,
                                           layers = c("sdlg<5", "saplg<10", "saplg<15","Total"), subtitle =NULL,
                                           title = "Number of stems (nstems)", y.label= nstem_size_regrowth@quant@units)


  }else{
    nstem_size_regrowth_mean_p <- plotTemporal(nstem_size_regrowth,
                                           layers = c("sdlg<1", "sdlg<5", "saplg<10", "saplg<15","Total"), subtitle =NULL,
                                           title = "Number of stems (nstems)", y.label= nstem_size_regrowth@quant@units)



  }

# I use vegetation carbon content as proxy for checking for possible competition/coexistence with grasses at the beginning
cveg <- get_model_output(site=site, run="P0"
                         ,var= "cveg",model_name=model_name, co2_levels = "412ppm")
cveg@data <- cveg@data[1:n,]
cveg_regrowth <- omit_equilibrium_phase(data_object = cveg,site = site,model_name = model_name,selection_by_year = TRUE)

cveg_regrowth <- calculate_vegetation_percentage_fraction(cveg_regrowth)

if(smoothing){
  cveg_regrowth <- create_rolling_means(var_to_plot = cveg,k=30,total_only=FALSE,align="left",rm_firstX_years=32)

}#plotTemporal(cveg_regrowth_mean) # only Total was treated here. Cannot interpret sizeclass output
cveg_regrowth_mean_p <- plotTemporal(cveg_regrowth , subtitle = NULL, title = paste0("Vegetation carbon (cveg)",site), y.label= cveg_regrowth@quant@units)


#EDv3 do not have CA:
if( model_name =="EDv3"){

  CA_regrowth@data$Total <- NA # enable plotting, but show that these models don't do this variable.
  CA_regrowth_mean_p <- plotTemporal(CA_regrowth,layers = c("Total"),
                                     subtitle = NULL, title = paste0("Crown area (CA)",model_name),
                                     y.label= CA_regrowth@quant@units)

}else{

  #I want to use Crown area as proxy for light-competition.
  CA <- get_model_output(site=site, run="P0",var= "CA",model_name=model_name, co2_levels = "412ppm")

  CA@data <- CA@data[1:n,]
  if(sum(names(CA@data) %in% c("Grasses") == 1)){ # to check for light- competition between trees, I need to remove the Grasses from CA, if a model has that reported as part of its total:
      CA@data$Total <- CA@data$Total-CA@data$Grasses
      CA@data$Grasses <- NA
  }

 if( model_name =="BiomeE-Standalone" |model_name =="BiomeEP"){
  #PPA approach- CAI is more informative:
  CA@data$Total <- CA@data$Total/10000 # enable plotting, but show that these models don't do this variable.
}

  CA_regrowth <- omit_equilibrium_phase(data_object = CA,site = site,model_name = model_name,selection_by_year = TRUE)

  if(smoothing){
  CA_regrowth <- create_rolling_means(var_to_plot =
                                             CA_regrowth,k=30,total_only=TRUE,align="left",rm_firstX_years=NULL)
  }

  #plotting different crown areas:
  if(model_name == "BiomeE-Standalone"|model_name =="BiomeEP"){
      CA_regrowth_mean_p <- plotTemporal(CA_regrowth,layers = c("Total"),
                                     subtitle = NULL, title = paste0("Crown area index (CAI)",model_name),
                                     y.label= "-")
  }else{
      CA_regrowth_mean_p <- plotTemporal(CA_regrowth,layers = c("Total"),
                                     subtitle = NULL, title = paste0("Crown area (CA)",model_name),
                                     y.label= CA_regrowth@quant@units)
  }
}
grid.arrange(cmort_rate_regrowth_mean_p,nstem_size_regrowth_mean_p,CA_regrowth_mean_p,cveg_regrowth_mean_p)
  }

}


#dev.off()


#now combining them to a larger table
nstem_size_estab_upto10$sclass <- "<10"
nstem_size_estab_10plus$sclass <- "<15"
nstem_size_estab <- rbind(nstem_size_estab_upto10,nstem_size_estab_10plus)
#year1 <- nstem_size_estab


```

used for manual alignment of cmort 
```{r mortality_rates_%kgCyr}
#create mortality rates from flux variable cmort_size and pool variable cwood, where possible.
#remove small sizeclasses, that way this output becomes more relevant when directly comparing to observations.
#note that FATES uses non-woody mortality flux, so we have to compute a full vegetation biomass turnover for FATES


#upper plot range:
xmax <- 430
k = 30

mort <- data.frame(matrix(ncol = length(models_avail), nrow = 810))
colnames(mort) <- models_avail
mort           <- list(mort,mort,mort)
names(mort)    <- sites
mort_unsmoothed <- mort

var_names_cmort_rates <- data.frame(lower=rep(NA,9))
                            #"JULES-RED"    "FATES"   "ORCHIDEE" "LPJ-GUESS"  "CABLE-POP"            "BiomeEP"  "BiomeE-Standalone" "SEIB-DGVM" "EDv3"
 # cmort should be by sizeclass but naming got messy, so listing the relevant variables here:
var_names_cmort_rates$cwood  <- c("cwood_size",   "cveg_total",  "AGcwood" ,"cwood_size",   "cwood_size", "cwood" ,  "cwood_size", "cwood_size" , "cwood_size")
var_names_cmort_rates$cmort  <- c("cmort"     ,        "cmort",     "cmort",     "cmort",        "cmort",  "cmort",  "cmort_size",  "cmort"     ,      "cmort")
var_names_cmort_rates$model  <- models_avail



for(site in sites){

  for (model_name in models_avail){

    #get variable:
    var= var_names_cmort_rates[which(var_names_cmort_rates$model==model_name),]$cmort

    # get model output:
    out_tmp  <- get_model_output(site=site, run="P0",var= var,model_name=model_name, co2_levels = "412ppm")
    # update mortality rates based on only sizclasses >10dbh, flexibly in this function since some models do not report all small sizeclasses
    out <-  out_tmp#omit_sizeclasses_below10dbh(out_tmp)

    if(model_name=="ORCHIDEE" | model_name =="CABLE-POP"| model_name =="FATES" ){ # no sizeclasses ( for this analysis)

      #get variable:
      var= var_names_cmort_rates[which(var_names_cmort_rates$model==model_name),]$cwood
      outac <- get_model_output(site=site, run="P0",var= var,model_name=model_name, co2_levels = "412ppm")
      #get variable:
      var= var_names_cmort_rates[which(var_names_cmort_rates$model==model_name),]$cmort
      out   <- get_model_output(site=site, run="P0",var= var,model_name=model_name, co2_levels = "412ppm")

    }else {
      # get model output:
      outac_tmp  <- get_model_output(site=site, run="P0",var= "cwood_size",model_name=model_name, co2_levels = "412ppm")
      # update cwood output based on only sizclasses >10dbh, flexibly, in this function since some models do not report all small sizeclasses
      outac <- outac_tmp#omit_sizeclasses_below10dbh(outac_tmp)
    }

  # now create rates. Now we have no problem with subsetting anymore, but can directly apply the function:
  # using it for growth rate
  mort_rate <- create_mort_rate(mort_in = out,total = outac,var_in = "cmort_rate")

  #remove years before disturbance:
  mort_rate <- omit_equilibrium_phase(mort_rate,model_name = model_name,site=site,selection_by_year = TRUE)

  # adress some "NaN" and inf. where either no trees or no mortality flux at the
  # start of recovery, and therefore the maths hasn't worked on those years.
  # Now correct that: when there is 0 mortality flux, then mortality rate is 0.0.
  # likewise, when there is no tree, tree mortality rate is 0. So changing these instances
  # to rate = 0
  Total <- mort_rate@data$Total
  Total[is.na(Total)|is.infinite(Total)] <- 0.0
  mort_rate@data$Total <- Total

  # now creating rolling means of rates:
  mort_rate_means <- create_rolling_means(mort_rate,k = k,total_only = TRUE,
                                              align = "left")@data$Total
  end <- length(mort_rate_means)
  mort[[site]][1:end,model_name] <- mort_rate_means

  #collect unsmoothed mortality rates, needed for normalisation in spaghetti plot later:
  mort_unsmoothed[[site]][1:end,model_name]  <-  mort_rate@data$Total

  }# models_avail
}# sites



# adress some "NaN" and inf. where either no trees or no mortality flux at the
# start of recovery, and therefore the maths hasn't worked on those years.
# Now correct that: when there is 0 mortality flux, then mortality rate is 0.0.
# likewise, when there is no tree, tree mortality rate is 0. So changing these instances
# to rate = 0
mort <- lapply(mort, function(df) {
  df[] <- lapply(df, function(x) ifelse(is.nan(x), 0.0, x))
  df[] <- lapply(df, function(x) ifelse(is.infinite(x), 0.0, x))
  return(df)
})

#now smoothing the rates:

  # now creating rolling means of rates:
  mort_rate_means <- create_rolling_means(mort_rate,k = k,total_only = TRUE,
                                                align = "left")@data$Total
########################################################
bitmap(file=paste0(Figs_dir,"FigS15_mortality_rates_FIN.png"),width=180,height=180,units="mm",res =380,type="png16m")

par(mfrow =c(3,4), oma=c(2,2,0.1,0.3), mar=c(2,2,1,0))

site="FIN"
# mortality rate ( woody carbon lost through mortality as percentage of total woody biomass present):

#individual model:
for(model_name in models_avail){
  plot(1:xmax,t(mort[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5,(max(t(mort[[site]][model_name]+3),na.rm = TRUE))),type="l",main=paste(model_name), ylab="", xlab="")
  mtext(abcdfeghijkl(model_name),side=3,line=-1.3,adj=0.98)
}




mtext(outer = TRUE,side=2,"Woody carbon mortality rate (%/yr)")
mtext(outer = TRUE,side=1,"Year after disturbance/ bare ground reset")

  plot.new()

  legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","ORCHIDEE","EDv3"),
       lty= 1,
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("ORCHIDEE"),
               get_model_colour("EDv3")),"center",cex=1.6 ,title = "DVMs",box.lwd = 0,box.col = "white",bg = "white")

dev.off()


########################################################
bitmap(file=paste0(Figs_dir,"FigS16_mortality_rates_BIA.png"),width=180,height=180,units="mm",res =380,type="png16m")

par(mfrow =c(3,4), oma=c(2,2,0.1,0.3),mar=c(2,2,1,0))

site="BIA"
# mortality rate ( woody carbon lost through mortality as percentage of total woody biomass present):

#individual model:
for(model_name in models_avail){
  plot(1:xmax,t(mort[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5,(max(t(mort[[site]][model_name]+3),na.rm = TRUE))),type="l",main=paste(model_name), ylab="", xlab="")
  mtext(abcdfeghijkl(model_name),side=3,line=-1.3,adj=0.98)
}




mtext(outer = TRUE,side=2,"Woody carbon mortality rate (%/yr)")
mtext(outer = TRUE,side=1,"Year after disturbance/ bare ground reset")

  plot.new()

  legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","ORCHIDEE","EDv3"),
       lty= 1,
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("ORCHIDEE"),
               get_model_colour("EDv3")),"center",cex=1.6,title = "DVMs",box.lwd = 0,box.col = "white",bg = "white")

dev.off()


########################################################
bitmap(file=paste0(Figs_dir,"FigS17_mortality_rates_BCI.png"),width=180,height=180,units="mm",res =1300,type="png16m")

par(mfrow =c(3,4), oma=c(2,2,0.1,0.3),mar=c(2,2,1,0))

site="BCI"
# mortality rate ( woody carbon lost through mortality as percentage of total woody biomass present):

#individual model:
for(model_name in models_avail){
  plot(1:xmax,t(mort[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5,(max(t(mort[[site]][model_name]+3),na.rm = TRUE))),type="l",main=paste(model_name), ylab="", xlab="")
  mtext(abcdfeghijkl(model_name),side=3,line=-1.3,adj=0.98)
}


mtext(outer = TRUE,side=2,"Woody carbon mortality rate (%/yr)")
mtext(outer = TRUE,side=1,"Year after disturbance/ bare ground reset")

  plot.new()

  legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3"),
       lty= 1,
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("EDv3")),"center",cex=1.6, title = "DVMs",box.lwd = 0, box.col = "white",bg = "white")
dev.off()


```

```{r growth_rate_kgCm2yr,eval=FALSE}
#Not presented in publication.

#upper plot range:
xmax <- 250
k = 30

growth <- data.frame(matrix(ncol = length(models_avail), nrow = 810))
colnames(growth) <- models_avail
growth           <- list(growth,growth,growth)
names(growth)    <- sites

for(site in sites){

  for (model_name in models_avail){

    #get variable:
    var= "WBgrowth"

    # get model output:
    out_tmp  <- get_model_output(site=site, run="P0",var= var,model_name=model_name, co2_levels = "412ppm")
    # update mortality rates based on only sizclasses >10dbh, flexibly in this function since some models do not report all small sizeclasses
    out <-  out_tmp#omit_sizeclasses_below10dbh(out_tmp)

    #remove years before disturbance:
    WBgrowth <- omit_equilibrium_phase(out,model_name = model_name,site=site,selection_by_year = TRUE)

    if(model_name=="SEIB-DGVM"){
      #allow for 10-year smoothing in SEIB-DGVM:
      #H.Sato 29.10.2024: "This issue likely arises from the different timings used to calculate growth flux and mortality flux.
      #Since this is an individual-based model, the death of a large individual has a pronounced effect.
      #By using a 10-year moving average, these negative values are expected to disappear."
      WBgrowth <- create_rolling_means(WBgrowth,k=10,total_only=TRUE, align="left")
    }

    # adress some "NaN" and inf. where either no trees or no growth flux at the
    # start of recovery, and therefore the maths hasn't worked on those years.
    # Now correct that: when there is 0 growth flux, then growth rate is 0.0.
    # likewise, when there is no tree, tree growth rate is 0. So changing these instances
    # to rate = 0
    Total <- WBgrowth@data$Total
    Total[is.na(Total)|is.infinite(Total)] <- 0.0
    WBgrowth@data$Total <- Total

    # now creating rolling means of rates:
    mort_rate_means <- create_rolling_means(WBgrowth,k = k,total_only = TRUE,
                                                align = "left")@data$Total
    end <- length(mort_rate_means)
    growth[[site]][1:end,model_name] <- mort_rate_means

  }# models_avail
}# sites




#now smoothing the rates:

  # now creating rolling means of rates:
  mort_rate_means <- create_rolling_means(mort_rate,k = k,total_only = TRUE,
                                                align = "left")@data$Total
########################################################
#bitmap(file=paste0(Figs_dir,"SXX_growth_rates_FIN.png"),width=180,height=180,units="mm",res =380,type="png16m")

par(mfrow =c(3,4), oma=c(2,2,0.1,0.3), mar=c(2,2,1,0))

site="FIN"
# mortality rate ( woody carbon lost through mortality as percentage of total woody biomass present):

#individual model:
for(model_name in models_avail){
  plot(1:xmax,t(growth[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5,(max(t(growth[[site]][model_name]+3),na.rm = TRUE))),type="l",main=paste(model_name), ylab="", xlab="")
  mtext(abcdfeghijkl(model_name),side=3,line=-1.3,adj=0.98)
}



mtext(outer = TRUE,side=2,"Woody growth fluxes ( kgC/m2/yr")
mtext(outer = TRUE,side=1,"Year after disturbance/ bare ground reset")

  plot.new()

  legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","ORCHIDEE","EDv3"),
       lty= 1,
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("ORCHIDEE"),
               get_model_colour("EDv3")),"center",cex=1.6 ,title = "DVMs",box.lwd = 0,box.col = "white",bg = "white")

#dev.off()


########################################################
#bitmap(file=paste0(Figs_dir,"SXX_growth_rates_BIA.png"),width=180,height=180,units="mm",res =380,type="png16m")

par(mfrow =c(3,4), oma=c(2,2,0.1,0.3),mar=c(2,2,1,0))

site="BIA"
# mortality rate ( woody carbon lost through mortality as percentage of total woody biomass present):

#individual model:
for(model_name in models_avail){
  plot(1:xmax,t(growth[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5,(max(t(growth[[site]][model_name]+3),na.rm = TRUE))),type="l",main=paste(model_name), ylab="", xlab="")
  mtext(abcdfeghijkl(model_name),side=3,line=-1.3,adj=0.98)
}




mtext(outer = TRUE,side=2,"Woody carbon WBgrowth rate (%/yr)")
mtext(outer = TRUE,side=1,"Year after disturbance/ bare ground reset")

  plot.new()

  legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","ORCHIDEE","EDv3"),
       lty= 1,
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("ORCHIDEE"),
               get_model_colour("EDv3")),"center",cex=1.6,title = "DVMs",box.lwd = 0,box.col = "white",bg = "white")

#dev.off()


########################################################
#bitmap(file=paste0(Figs_dir,"SXX_growth_rates_BCI.png"),width=180,height=180,units="mm",res =1300,type="png16m")

par(mfrow =c(3,4), oma=c(2,2,0.1,0.3),mar=c(2,2,1,0))

site="BCI"

#individual model:
for(model_name in models_avail){
  plot(1:xmax,t(growth[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5,(max(t(growth[[site]][model_name]+3),na.rm = TRUE))),type="l",main=paste(model_name), ylab="", xlab="")
  mtext(abcdfeghijkl(model_name),side=3,line=-1.3,adj=0.98)
}


mtext(outer = TRUE,side=2,"Woody carbon WBgrowth rate (%/yr)")
mtext(outer = TRUE,side=1,"Year after disturbance/ bare ground reset")

  plot.new()

  legend(legend = c("BiomeES","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3"),
       lty= 1,
       col = c(get_model_colour("BiomeE-Standalone"),
               get_model_colour("BiomeEP"),
               get_model_colour("CABLE-POP"),
               get_model_colour("FATES"),
               get_model_colour("JULES-RED"),
               get_model_colour("LPJ-GUESS"),
               get_model_colour("EDv3")),"center",cex=1.6, title = "DVMs",box.lwd = 0, box.col = "white",bg = "white")
#dev.off()




```

This is now figure 2 after revisions
```{r mort_growth_spaghetti_plot}
bitmap(file=paste0(Figs_dir,simdate,"/Figure2_mortality_growth_rates.png"),width=80,height=120,units="mm",res =480,type="png16m")


#collect growth and mort statistics during early recovery - prepare extended data frame:
FULL <- combined
FULL$variable <- "AGcwood"
FULL <- rbind(FULL, setNames(data.frame(matrix(NA, nrow=12, ncol=ncol(FULL))), names(FULL)))
FULL$variable[7:12] <- "WBgrowth"
FULL$State[7:9] <- "min within 30 first years"
FULL$State[10:12] <- "max within 30 first years"
FULL$sites[7:12]  <- rep(sites,2)
FULL$variable[13:18] <- "cmort_rate%"
FULL$State[13:15] <- "min within 30 first years"
FULL$State[16:18] <- "max within 30 first years"
FULL$sites[13:18]  <- rep(sites,2)

par(mfcol =c(3,2), oma=c(4.2,0,0.1,0.3),mar=c(0,3,0,0.5))

normalise=FALSE  #Switch to  equilibrium normalised plots if TRUE

for (site in sites){


  if(normalise){

    mort_tst <- cbind(time=1:250,mort[[site]][c(1:250),])
    data_df <- mort_tst

    # Calculate equilibrium values for each time series (excluding 'time' column)
    equilibrium_values <- colMeans(data_df[(nrow(data_df) - 19):nrow(data_df), -1])  # Customize window for equilibrium

    #actually,- better use real equilibrium for the normalisation:
    for(model_name in models_avail){


     # extract the equilibrium phase, and use those years for normalisation:
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower-30#oomit equilibrium period
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper-30

    #create normaliser ; last value of vector
    equilibrium_values[[model_name]]    <- mean(t(mort[[site]][model_name])[lower:upper],na.rm=TRUE)
    }

    mort_tst <- cbind(time=1:250,mort[[site]][c(1:250),])
    data_df <- mort_tst

    # Calculate equilibrium values for each time series (excluding 'time' column)
    equilibrium_values <- colMeans(data_df[(nrow(data_df) - 19):nrow(data_df), -1])  # Customize window for equilibrium

    # Subtract equilibrium values from each column to center the series
    aligned_df <- data_df
    aligned_df[-1] <- sweep(data_df[-1], 2, equilibrium_values)  # Align by subtracting equilibrium

    # Plot the centered time series with a horizontal line at y=0
    matplot(1:250, as.matrix(aligned_df[-1]), type = "l", lty = 1, col = c(palette.colors()[c(7,5,6,3,9,8,2)],"#BCE9C5",palette.colors()[c(4)]),
            ylab = "",xlab="",xaxt="n",lwd=1, yaxt="n")
  }else{
  #all models in one:
  for (model_name in models_avail){
    if(model_name == models_avail[1]){

    # extract the equilibrium phase, and use those years for normalisation:
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower-30#oomit equilibrium period
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper-30

    #create normaliser ; last value of vector
    eq    <- t(mort[[site]][model_name])[2]

      plot(1:xmax,t(mort[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5, 15),type="l",ylab="",xaxt="n",lwd=1, yaxt="n")
    }else{
      lines(1:xmax,t(mort[[site]][model_name])[1:xmax], col = get_model_colour(model_name) ,lwd=1)

    }
  }
      }



  axis(1, lwd = 0, lwd.ticks = 1, tck = 0.02,labels=F)
  axis(side=2,tick = F,line = -0.7)
  axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
  mtext(paste0(def(site)),adj=0.97,side=3,line=-1.4)

  if(site=="BIA"){
    # add legend into FIN, there is the most space:
    legend(legend = c("BiomeE","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE"),
         lty= 1,lwd=2.3,
         col = c(get_model_colour("BiomeE-Standalone"),
                 get_model_colour("BiomeEP"),
                 get_model_colour("CABLE-POP"),
                 get_model_colour("FATES"),
                 get_model_colour("JULES-RED"),
                 get_model_colour("LPJ-GUESS"),
                 get_model_colour("EDv3"),
                 get_model_colour("SEIB-DGVM"),
                 get_model_colour("ORCHIDEE")),"topright", ncol = 2, box.lwd = 0)

  }

}

axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=T)


for (site in sites){


  if(normalise){
   mort_tst <- cbind(time=1:250,growth[[site]][c(1:250),])
    data_df <- mort_tst

    # Calculate equilibrium values for each time series (excluding 'time' column)
    equilibrium_values <- colMeans(data_df[(nrow(data_df) - 19):nrow(data_df), -1])  # Customize window for equilibrium

    #actually,- better use real equilibrium for the normalisation:
    for(model_name in models_avail){


     # extract the equilibrium phase, and use those years for normalisation:
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower-30#oomit equilibrium period
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper-30

    #create normaliser ; last value of vector
    equilibrium_values[[model_name]]    <- mean(t(growth[[site]][model_name])[lower:upper],na.rm=TRUE)
    }

    # Subtract equilibrium values from each column to center the series
    aligned_df <- data_df
    aligned_df[-1] <- sweep(data_df[-1], 2, equilibrium_values)  # Align by subtracting equilibrium

    # Plot the centered time series with a horizontal line at y=0
    matplot(1:250, as.matrix(aligned_df[-1]), type = "l", lty = 1, col = c(palette.colors()[c(7,5,6,3,9,8,2)],"#BCE9C5",palette.colors()[c(4)]),
            ylab = "",xlab="",xaxt="n",lwd=1, yaxt="n")
  }else{
  #all models in one:
  for (model_name in models_avail){
    if(model_name == models_avail[1]){


      plot(1:xmax,t(growth[[site]][model_name])[1:xmax], col = get_model_colour(model_name) , ylim=c(-0.5, 1.5),type="l",ylab="",xaxt="n",lwd=1, yaxt="n")
    }else{
      lines(1:xmax,t(growth[[site]][model_name])[1:xmax], col = get_model_colour(model_name),lwd=1 )

    }
  }
    }
  axis(1, lwd = 0, lwd.ticks = 1, tck = 0.02,labels=F)
  axis(side=2,tick = F,line = -0.7)
  axis(2, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
  mtext(paste0(ghi(site)),adj=0.97,side=3,line=-1.4)
}

axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=F)
axis(1, lwd = 0, lwd.ticks = 1, tck = -0.02,labels=T)

#mtext(outer=TRUE,expression("Woody biomass increment rate ("KgCm^2yr^-1")"),side=2, line = -25) # expression("Growth Rate (" ~ kg ~ C / m^2 / yr ~ ")"))
mtext(expression("Woody biomass increment rate (kgCm"^-2~"yr"^-1~")"), side=2, line=-25.5, outer=TRUE)
#expression(log(nstems)~(nstems~ha^-1))
mtext(outer=TRUE,expression("Woody biomass mortality rate (% yr"^-1~")"),side=2, line=-1.65)
mtext(outer=TRUE,"Year since disturbance",side=1, line=2.3)
dev.off()


#record individual model:
xmax=30 # first 30 years
for(model_name in models_avail){
  for(site in sites){
    FULL[which(FULL$sites==site),][[model_name]][3] <- min(t(growth[[site]][model_name])[1:xmax])# record min growth value within 30 yrs
    FULL[which(FULL$sites==site),][[model_name]][4] <- max(t(growth[[site]][model_name])[1:xmax])# record max growth value within 30 yrs
    FULL[which(FULL$sites==site),][[model_name]][5] <- min(t(mort[[site]][model_name])[1:xmax])  # record min mort value within 30 yrs
    FULL[which(FULL$sites==site),][[model_name]][6] <- max(t(mort[[site]][model_name])[1:xmax])  # record max mort value within 30 yrs
  
  }
  
}


#summarise across models ( min of max and min and max of max and min):
FULL$`SEIB-DGVM`[7:12] <- NA #  WBgrowth in SEIB not valid
FULL$min[7:12]  <- apply(FULL[which(FULL$variable =="WBgrowth"),1:9],1,min,na.rm=TRUE)
FULL$max[7:12]  <- apply(FULL[which(FULL$variable =="WBgrowth"),1:9],1,max,na.rm=TRUE)
FULL$min[13:18] <- apply(FULL[which(FULL$variable =="cmort_rate%"),1:9],1,min,na.rm=TRUE)
FULL$max[13:18] <- apply(FULL[which(FULL$variable =="cmort_rate%"),1:9],1,max,na.rm=TRUE)


knitr::kable(FULL,caption = "Collection of Variables summarised across the first 30 years of regrowth and equilibrium. Aboveground woody carbon (AGcwood, KgC m2) after 30 years of disturbance recovery, and at equilibrium, by model and site. WBgrowth fluxes and cmort rates (%) minimum and maximum rates within the first 30 years, and the minimum and maximum across models across these years.")

#saving FULL and creating it in word-document table format in all_models_30year_summary_stats.Rmd, knitting it as word document.
save(FULL,file = "../model_outputs/all_models_30year_summary_stats.RData")
```



#Supplementary materials
## PFT sucession

"For example, the double-hump in growth rate changes in LPJ-GUESS, BiomeE and BiomeEP is caused by a change in PFT species composition (more clearly seen in %cveg, supplementary materials)"

```{r PFT_succession}

library(grid)
create_gobj <- function(model_out, y.lim = NULL,layers=NULL){
  if(model_out@source@name ==  "LPJGUESS BCI - P0"){ # enhance title, so that the reader understands what layers are currently plotted
    p_out <- plotTemporal(model_out, legend.position = "none", layers=layers,title = paste(model_out@source@name," \n", layers), y.lim ,x.label = "Years",text.multiplier = 0.55)
  }else{# if everything is plotted:
    p_out <- plotTemporal(model_out, legend.position = "bottom", layers=layers,y.lim, title = paste(model_out@source@name," \n", layers),subtitle = NULL,
                          text.multiplier = 0.55,x.label = "Years")

  }

  return(p_out)
}

bitmap(file=paste0(Figs_dir,simdate,"/FigS14_growth_rates_and_succession.png"),width=80,height=120,units="mm",res =480,type="png16m")

par(mfcol =c(1,2), oma=c(4.2,0,0.8,1.5),mar=c(0,3,0,1))

var  = "WBgrowth"
run  = "P0"
site = "BIA"

LPJG     <- get_model_output(var = var,run=run,site = site,model_name = "LPJ-GUESS",co2_levels = "412ppm")
BiomeE_standlone <- get_model_output(var = var,run=run,site = site,model_name = "BiomeE-Standalone",co2_levels = "412ppm")

LPJG <- create_rolling_means(LPJG, k=30, rm_firstX_years = 32)

p_LPJG <- create_gobj(LPJG)
BiomeE_standlone <- create_rolling_means(BiomeE_standlone,k=30, rm_firstX_years = 32)

p_BiomeE_standlone <- create_gobj(BiomeE_standlone)

grid.arrange(p_LPJG,p_BiomeE_standlone)
#mtext 
dev.off()


######modifying function quickly for a better layout:
create_gobj_nolegend <- function(model_out, y.lim = NULL,layers=NULL){
  #if(model_out@source@name ==  "LPJGUESS BCI - P0"){ # enhance title, so that the reader understands what layers are currently plotted
  x <- model_out@source@name
xprint <- sub(" .*", "", x)
    p_out <- plotTemporal(model_out, legend.position = "none", layers=layers,title ="",subtitle= paste(xprint), y.lim ,x.label = "",y.label="",text.multiplier = 0.8)
#  }else{# if everything is plotted:
#    p_out <- plotTemporal(model_out, legend.position = "bottom", layers=layers,y.lim, title = paste(model_out@source@name," \n", layers),subtitle = NULL,
#                          text.multiplier = 0.8,x.label = "Years",sizes)

#  }

  return(p_out)
}
#bitmap(file=paste0(Figs_dir,simdate,"/S19_all_models_biomass_succession.png"),width=80,height=120,units="mm",res =480,type="png16m")
pdf(file=paste0(Figs_dir,"FigS19_all_models_biomass_succession.pdf"))

# only models with between-PFT competition:
models_avail_succession <- models_avail[-c(3,5)]
var  = "cveg"
run  = "P0"
  
for(site in sites){
  
 # par(mfcol =c(3,4), oma=c(4.2,0,0.1,1.3),mar=c(0,3,0,0.5))
  
  #for(model_name in models_avail_succession){
    
    JRED     <- get_model_output(var = var,run=run,site = site,model_name =
                                           "JULES-RED",co2_levels = "412ppm")
    FATES    <- get_model_output(var = var,run=run,site = site,model_name =
                                           "FATES",co2_levels = "412ppm")
    LPJG     <- get_model_output(var = var,run=run,site = site,model_name =
                                   "LPJ-GUESS",co2_levels = "412ppm")
    LPJG@data <- LPJG@data[which(LPJG@data$Year<=800),]
    
    BiomeEP  <- get_model_output(var = var,run=run,site = site,model_name =
                                           "BiomeEP",co2_levels = "412ppm")
    #reduce years to 450, equilibrium occurs early, unlike in BiomeE-Standalone, where plotting longer timeseries makes sense to show the dynamics:
    BiomeEP@data <- BiomeEP@data[which(BiomeEP@data$Year<=450),]
    
    BiomeE_standlone <- get_model_output(var = var,run=run,site = site,model_name =
                                           "BiomeE-Standalone",co2_levels = "412ppm")
    SEIB <- get_model_output(var = var,run=run,site = site,model_name =
                                         "SEIB-DGVM",co2_levels = "412ppm")
    EDv3 <- get_model_output(var = "cwood",run=run,site = site,model_name =
                                           "EDv3",co2_levels = "412ppm")
    
    
    JRED <- create_rolling_means(JRED, k=30, rm_firstX_years = 32)
    p_JRED <- create_gobj_nolegend(JRED)
    p_JRED_legend <-  plotTemporal(JRED, legend.position = "right", 
                          text.multiplier = 0.7)
    
    FATES <- create_rolling_means(FATES, k=30, rm_firstX_years = 32)
    p_FATES <- create_gobj_nolegend(FATES)
    
    LPJG <- create_rolling_means(LPJG, k=30, rm_firstX_years = 32)
    p_LPJG <- create_gobj_nolegend(LPJG)
    
    BiomeEP <- create_rolling_means(BiomeEP, k=30, rm_firstX_years = 32)
    p_BiomeEP <- create_gobj_nolegend(BiomeEP)
    
    BiomeE_standlone <- create_rolling_means(BiomeE_standlone,k=30, rm_firstX_years = 32)
    p_BiomeE_standlone <- create_gobj_nolegend(BiomeE_standlone)
    
    SEIB <- create_rolling_means(SEIB, k=30, rm_firstX_years = 32)
    p_SEIB <- create_gobj_nolegend(SEIB)
    
    EDv3 <- create_rolling_means(EDv3, k=30, rm_firstX_years = 32)
    p_EDv3 <- plotTemporal(EDv3, legend.position = "none", y.label =
                             paste(EDv3@quant@name,"\n",EDv3@quant@units),
                           x.label = "", title ="", subtitle= "EDv3",text.multiplier = 0.8)
#                          
    #last one for a legend: 
    p <- as_ggplot(get_legend(p_JRED_legend))
    grid.arrange(
      p_JRED, p_FATES, p_LPJG, nullGrob(),
      p_BiomeEP, p_BiomeE_standlone, p_SEIB,p,
      p_EDv3,nullGrob(),nullGrob(),
      ncol = 4,
      nrow = 3,
      widths = c(1, 1, 1, 0.5),  # Legend column is 40% the width of others
      bottom = grid::textGrob("Year"),
      top = grid::textGrob(paste(site)),
      left = grid::textGrob(paste(LPJG@quant@name, LPJG@quant@units), rot = 90)
    )
}




#file.dir.EDv3=file.dir.EDv3_backup#=file.dir.EDv3
#file.dir.EDv3="/Users/annemarie/Library/CloudStorage/OneDrive-LundUniversity/1_TreeMort_onedrive/2_Analysis/3_analysis_demographic_model_intercomparison/D-BEN-site-sims/Paper_1/Outputs/EDv3/v3"
dev.off()

```


"Regrowth speed does not seem to be linked to final equilibrium biomass values."

```{r turnover_times_}
bitmap(file=paste0(Figs_dir,"/FigS18_regrowth_speed_biomass_equilibrium.png"),width=80,height=120,units="mm",res =480,type="png16m")

#prepare dataframe that collects all variables for plotting:
collect_turnover_npp <- data.frame(Mname=models_avail,turnover =NA,npp =NA,regr100 = NA,eq_biomass = NA,site= "BCI")
collect_turnover_npp <- rbind( collect_turnover_npp,data.frame(Mname=models_avail,turnover =NA,npp =NA,eq_biomass = NA,regr100 = NA,site= "BIA") )
collect_turnover_npp <- rbind(collect_turnover_npp,data.frame(Mname=models_avail,turnover =NA,npp =NA,eq_biomass = NA,regr100 = NA,site= "FIN") )

for(site in sites){
  for(model_name in models_avail){
    cmort  <- get_model_output(var="cmort",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
    cwood  <- get_model_output(var="AGcwood",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
    #cwood     <- omit_equilibrium_phase(cwood_in,model_name = model_name,site=site)
    #cmort     <- omit_equilibrium_phase(cmort_in,model_name = model_name,site=site)

     # extract the equilibrium phase, and use those years for analysis:
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper
    #eq <- model_out@data$Total[lower:upper]

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$turnover    <- mean(cwood@data$Total[lower:upper])/mean(cmort@data$Total[lower:upper])

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$turnover    <- mean(cwood@data$Total[33:70])/mean(cmort@data$Total[33:70])

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$eq_biomass    <- mean(cwood@data$Total[lower:upper])

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$regr100     <- cwood@data$Total[50 + 30] /50 # regrowth rate over 50 years

    npp_in   <- get_model_output(var="npp",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
    npp      <- omit_equilibrium_phase(npp_in,model_name = model_name,site=site)

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$npp <- mean(npp@data$Total[1:70])
    }
}


par(mfcol=c(3,2), oma=c(6,2,1,1), mar=c(0,2,0,2))

# regrowth speed against eq biomass
#"Regrowth speed in the first 100 years does not seem to be linked to final equilibrium biomass values, probably because the initial conditions of the models differ so strongly."
for(site in sites){
  plot("n",xlim=c(0,0.33),ylim=c(0,23), xaxt="n")

     for(model_name in models_avail){
       points(collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$regr100,
           collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$eq_biomass
           ,ylim=c(0,50),col=get_model_colour(model_name),pch=16,cex=2)
    }
   mtext("eq. biomass (KgC m-2)",side=2, line=2)


    # Fit the linear model
    model <- lm(eq_biomass ~ regr100, data = collect_turnover_npp[which(collect_turnover_npp$site==site),])

    print(summary(model))
    summary_model <- summary(model)
    abline(model, col="red")
    p_value <- round(summary_model$coefficients["regr100", "Pr(>|t|)"],digits = 3)
    rsq = round(summary_model$r.squared,digits=3)
    mtext(paste("p=",p_value),side=3, line=-1.3, adj=0.99)
    mtext(paste0("r2= ", rsq,","), side=3,line =-1.3, adj =0.45)

   axis(1, lwd = 0, lwd.ticks = 1, tck = 0.02,labels=F)
  mtext(paste0(abc(site)),adj=0.01,side=3,line=-1.3,cex = 0.8)
  mtext(paste(site),side=3,adj=0.077,line=-1.3)
}

axis(side=1,labels=TRUE,tick=TRUE)
mtext("mean annual regrowth rate \n over first 50 years (kgC yr-1)",side=1, line=4)

for(site in sites){
 plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", main = "")
   if(site=="BIA"){
    # add legend into FIN, there is the most space:
    legend(legend = c("BiomeE","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE"),
         lty= 1,lwd=2.3,
         col = c(get_model_colour("BiomeE-Standalone"),
                 get_model_colour("BiomeEP"),
                 get_model_colour("CABLE-POP"),
                 get_model_colour("FATES"),
                 get_model_colour("JULES-RED"),
                 get_model_colour("LPJ-GUESS"),
                 get_model_colour("EDv3"),
                 get_model_colour("SEIB-DGVM"),
                 get_model_colour("ORCHIDEE")),"topright", ncol = 2, box.lwd = 0)

  }

}

dev.off()

```


```{r eval=FALSE,other_interesting_bits_turnover_times}
#bitmap(file=paste0(Figs_dir,"/SXX_turnover_time_equilibrium.png"),width=80,height=120,units="mm",res =480,type="png16m")

#prepare dataframe that collects all variables for plotting:
collect_turnover_npp <- data.frame(Mname=models_avail,turnover =NA,npp =NA,regr100 = NA,eq_biomass = NA,site= "BCI")
collect_turnover_npp <- rbind( collect_turnover_npp,data.frame(Mname=models_avail,turnover =NA,npp =NA,eq_biomass = NA,regr100 = NA,site= "BIA") )
collect_turnover_npp <- rbind(collect_turnover_npp,data.frame(Mname=models_avail,turnover =NA,npp =NA,eq_biomass = NA,regr100 = NA,site= "FIN") )

for(site in sites){
  for(model_name in models_avail){
    cmort  <- get_model_output(var="cmort",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
    cwood  <- get_model_output(var="AGcwood",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
    #cwood     <- omit_equilibrium_phase(cwood_in,model_name = model_name,site=site)
    #cmort     <- omit_equilibrium_phase(cmort_in,model_name = model_name,site=site)

     # extract the equilibrium phase, and use those years for analysis:
    lower <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$lower
    upper <- eq_values[[site]][which(eq_values[[site]]$model==model_name),]$upper
    #eq <- model_out@data$Total[lower:upper]

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$turnover    <- mean(cwood@data$Total[lower:upper])/mean(cmort@data$Total[lower:upper])

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$turnover    <- mean(cwood@data$Total[33:70])/mean(cmort@data$Total[33:70])

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$eq_biomass    <- mean(cwood@data$Total[lower:upper])

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$regr100     <- cwood@data$Total[70 + 30] /100 # regrowth rate over 100 years

    npp_in   <- get_model_output(var="npp",site=site,run="P0",model_name=model_name, co2_levels = "412ppm")
    npp      <- omit_equilibrium_phase(npp_in,model_name = model_name,site=site)

    collect_turnover_npp[which(collect_turnover_npp$Mname==model_name &collect_turnover_npp$site==site),]$npp <- mean(npp@data$Total[1:70])
    }
}


par(mfcol=c(3,2), oma=c(6,2,1,1), mar=c(0,2,0,2))

for(site in sites){
  plot("n",xlim=c(0,0.5),ylim=c(0,55), xaxt="n")

     for(model_name in models_avail){
       points(collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$regr100,
           collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$turnover
           ,ylim=c(0,50),col=get_model_colour(model_name),pch=16,cex=2)
    }
   mtext("C residence time (yr)",side=2, line=2)

    # Fit the linear model
    model <- lm(turnover ~ regr100, data = collect_turnover_npp[which(collect_turnover_npp$site==site),])

    summary(model)
    abline(model, col="red")
}
axis(side=1,labels=TRUE,tick=TRUE)

for(site in sites){
plot("n",xlim=c(0,0.5),ylim=c(0,2), xaxt="n")

     for(model_name in models_avail){
       points(collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$regr100,
           collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$npp,
           ylim=c(0,2),col=get_model_colour(model_name),pch=16, xlim=c(0,0.3),cex=2)
    }
   mtext("npp",side=2, line=2)
}

axis(side=1,labels=TRUE,tick=TRUE)
mtext(outer =TRUE, expression(AGcwood~(kgC~m^-2)),side=1, line=3)


# regrowth speed against eq biomass
#"Regrowth speed in the first 100 years does not seem to be linked to final equilibrium biomass values, probably because the initial conditions of the models differ so strongly."
for(site in sites){
  plot("n",xlim=c(0,0.2),ylim=c(0,23), xaxt="n")

     for(model_name in models_avail){
       points(collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$regr100,
           collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$eq_biomass
           ,ylim=c(0,50),col=get_model_colour(model_name),pch=16,cex=2)
    }
   mtext("eq. biomass (KgC m-2)",side=2, line=2)


    # Fit the linear model
    model <- lm(eq_biomass ~ regr100, data = collect_turnover_npp[which(collect_turnover_npp$site==site),])

    print(summary(model))
    summary_model <- summary(model)
    abline(model, col="red")
    p_value <- round(summary_model$coefficients["regr100", "Pr(>|t|)"],digits = 3)
    rsq = round(summary_model$r.squared,digits=3)
    mtext(paste("p=",p_value),side=3, line=-1.2, adj=0.9)
    mtext(paste("r2=", rsq), side=3,line =-1.2, adj =0.3)
}
axis(side=1,labels=TRUE,tick=TRUE)
mtext("mean annual regrowth rate \n over first 100 years (kgC yr-1)",side=1, line=4)

for(site in sites){
 plot(1, type = "n", axes = FALSE, xlab = "", ylab = "", main = "")
   if(site=="BIA"){
    # add legend into FIN, there is the most space:
    legend(legend = c("BiomeE","BiomeEP","CABLE-POP","FATES","JULES-RED","LPJ-GUESS","EDv3","SEIB-DGVM","ORCHIDEE"),
         lty= 1,lwd=2.3,
         col = c(get_model_colour("BiomeE-Standalone"),
                 get_model_colour("BiomeEP"),
                 get_model_colour("CABLE-POP"),
                 get_model_colour("FATES"),
                 get_model_colour("JULES-RED"),
                 get_model_colour("LPJ-GUESS"),
                 get_model_colour("EDv3"),
                 get_model_colour("SEIB-DGVM"),
                 get_model_colour("ORCHIDEE")),"topright", ncol = 2, box.lwd = 0)

  }

}

##########################################################################################################
 for(site in sites){
   plot(1:length(models_avail),rep(NA,length(models_avail)),ylim=c(0,50), xaxt="n")
    for( idx in 1:length(models_avail)){
     model_name = models_avail[idx]

      points(idx,
           collect_turnover_npp[which(collect_turnover_npp$site==site & collect_turnover_npp$Mname ==model_name),]$turnover,ylim=c(0,50),col=get_model_colour(model_name),pch=16, xlim=c(0,20),cex=2)


    }
   mtext("C residence time (yr)",side=2, line=2)
   }

      modelss <- c("JULES-RED"     ,    "FATES"       ,      "ORCHIDEE"         , "LPJ-GUESS"     ,    "CABLE-POP"      ,   "BiomeEP"       ,    "BiomeE", "SEIB-DGVM"    ,     "EDv3" )
   axis(labels=modelss,side=1,at=1:length(models_avail),las=3)

```


```{r Supplementary_analysis_temperature_distributions}

############

#address reviewers comment to contextualise the individual site's climate conditions in the regrowth curves.
# the commentedd out code creates latitude and longitude for all sites from whcih to extract climate forcing data for the below plot

library(ncdf4)
library(raster)  # or terra (newer) — here using raster for simplicity
library(terra)
library(geodata)

#load("../observations/2_processed/latlons_regrowth_obs.RData")
# add the sites to the samples:
#addthis <- data.frame(Lat = c(9.25, 52.75, 62.25), 
#  Lon = c(-79.75, 23.75, 23.25), 
#  Biome = c("Tropics_site", "Temperate_site", "Boreal_site"))
#samples <- rbind(latlons_samples,addthis)


#also get a subset of FIN sites:
#FIN <- worldclim_country(countr="Finland",var="tavg",path = "../observations/1_raw/temperature_data/climate/wc2.1_5m", res = 5)
#ins <- worldclim_global("tavg",path ="../observations/1_raw/temperature_data/", res = 5)
#No boreal data from FIN above >65*, ( we use "southern and central finland") so filter out:
# and turn into df:
#FIN_df <- as.data.frame(FIN, xy = TRUE)
#FIN_subs <- FIN_df[which(FIN_df$y<=65),]
#names(FIN_subs)[1:2] <- c("Lon","Lat")

#unique_coords <- round(unique(FIN_subs[c("Lat","Lon")]),digits = 1)
 # Randomly sample 200 rows
#set.seed(123)  # for reproducibility
#sampled_coords <- unique_coords %>%
# dplyr::slice_sample(n = 100)
#sampled_coords$Biome <- "Boreal"
#samples <- rbind(sampled_coords,samples)

# View the result
#head(samples)

#write.csv(samples,"/Volumes/My Passport/dben/forcing_data/latlons_samples.csv",row.names = FALSE)

#######################
INS <- read.csv("../observations/1_raw/temperature_data/extracted_annual_temperatures.csv",head=TRUE)
samples <- read.csv("../observations/1_raw/temperature_data/latlons_samples.csv",head=TRUE)
INS$mean_temperature = INS$mean_temperature -272.15 
names(INS)[3:4] <- c("Lat","Lon")

sample_data_crujra <- merge(INS,samples,by=c("Lon","Lat"))


png( paste0(Figs_dir,"FigS20_met_analysis.png"), width = 90, height = 180 ,units = "mm",res = 900)  # Adjust width, height, and resolution as needed

par(mfrow=c(3,1),mar=c(2,3,1,1),oma=c(2,2,0.1,0.1))
plot(density(sample_data_crujra[which(sample_data_crujra$Biome=="Boreal"),]$mean_temperature,na.rm=TRUE),col="black", main="",ylim=c(0,1),xlim=c(0,30))
lines(density(sample_data_crujra[which(sample_data_crujra$Biome=="Boreal_site" & sample_data_crujra$year>=1991),]$mean_temperature,na.rm=TRUE),col= get_biome_colour("Boreal"))
mtext("a)",side=3,adj=0.02, line=-1.2)


#rm nas, those must be coastal coordinates for which no forcing was availableL
plot(density(sample_data_crujra[which(sample_data_crujra$Biome=="Temperate"),]$mean_temperature,na.rm=TRUE),main="",ylim=c(0,0.6),xlim=c(0,30))
lines(density(sample_data_crujra[which(sample_data_crujra$Biome=="Temperate_site"),]$mean_temperature,na.rm=TRUE),col= get_biome_colour("Temperate"))
mtext("b)",side=3,adj=0.02, line=-1.2)

plot(density(sample_data_crujra[which(sample_data_crujra$Biome=="Tropics"),]$mean_temperature,na.rm=TRUE),main="",ylim=c(0,1.2),xlim=c(0,30))
lines(density(sample_data_crujra[which(sample_data_crujra$Biome=="Tropics_site"),]$mean_temperature,na.rm=TRUE),col= get_biome_colour("Tropics"))
mtext("c)",side=3,adj=0.02, line=-1.2)

 
mtext("Frequency of occurrence",side=2,outer=TRUE)
mtext("Mean annual Temperature, degC",side=1,outer=TRUE,line=0.7)
legend("bottomleft",legend=c("all regrowth samples","FIN","BIA","BCI"),fill=c(1,get_biome_colour("FIN"),get_biome_colour("BIA"),get_biome_colour("BCI")))
dev.off()

```



